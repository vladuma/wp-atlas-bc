'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const gqty = require('gqty');
const React = require('react');
const common = require('../common.js');

function UseMutationReducer(state, action) {
  switch (action.type) {
    case "loading": {
      if (state.isLoading)
        return state;
      return {
        data: state.data,
        isLoading: true
      };
    }
    case "success": {
      return {
        data: action.data,
        isLoading: false
      };
    }
    case "failure": {
      return {
        data: state.data,
        isLoading: false,
        error: action.error
      };
    }
  }
}
function InitUseMutationReducer() {
  return {
    data: void 0,
    isLoading: false
  };
}
function createUseMutation(client, {
  defaults: { mutationSuspense: defaultSuspense }
}) {
  const { resolved, refetch } = client;
  const clientMutation = client.mutation;
  const useMutation = function useMutation2(mutationFn, opts = {}) {
    var _a, _b;
    const optsRef = React.useRef(opts);
    optsRef.current = Object.assign({}, opts);
    (_b = (_a = optsRef.current).suspense) != null ? _b : _a.suspense = defaultSuspense;
    const setSuspensePromise = common.useSuspensePromise(optsRef);
    const [state, dispatchReducer] = React.useReducer(UseMutationReducer, void 0, InitUseMutationReducer);
    const dispatch = common.useDeferDispatch(dispatchReducer);
    const fnRef = React.useRef(mutationFn);
    fnRef.current = mutationFn;
    const callRefetchQueries = React.useCallback(() => {
      const { refetchQueries, awaitRefetchQueries } = optsRef.current;
      if (refetchQueries == null ? void 0 : refetchQueries.length) {
        const refetchPromise = Promise.all(refetchQueries.map((v) => refetch(v))).catch((err) => {
          dispatch({
            type: "failure",
            error: gqty.GQtyError.create(err, useMutation2)
          });
        });
        if (awaitRefetchQueries)
          return refetchPromise;
      }
    }, [optsRef, dispatch]);
    const mutate = React.useCallback(function mutateFn({
      fn: fnArg,
      args
    } = {}) {
      dispatch({ type: "loading" });
      const refFn = fnRef.current;
      const functionResolve = fnArg ? () => fnArg(clientMutation, args) : refFn ? () => refFn(clientMutation, args) : (() => {
        throw new gqty.GQtyError("You have to specify a function to be resolved", {
          caller: mutateFn
        });
      })();
      return resolved(functionResolve, {
        noCache: optsRef.current.noCache,
        refetch: true,
        nonSerializableVariables: optsRef.current.nonSerializableVariables
      }).then(async (data) => {
        var _a2, _b2;
        const refetchingQueries = callRefetchQueries();
        if (refetchingQueries)
          await refetchingQueries;
        (_b2 = (_a2 = optsRef.current).onCompleted) == null ? void 0 : _b2.call(_a2, data);
        dispatch({
          type: "success",
          data
        });
        return data;
      }, (err) => {
        var _a2, _b2;
        const error = gqty.GQtyError.create(err, useMutation2);
        (_b2 = (_a2 = optsRef.current).onError) == null ? void 0 : _b2.call(_a2, error);
        dispatch({
          type: "failure",
          error
        });
        throw error;
      });
    }, [optsRef, fnRef, dispatch, callRefetchQueries]);
    const { retry = false } = opts;
    return React.useMemo(() => {
      const fn = retry ? (...args) => {
        const promise = mutate(...args).catch((err) => {
          gqty.doRetry(retry, {
            onRetry: () => {
              const promise2 = mutate(...args).then(() => {
              });
              setSuspensePromise(promise2);
              return promise2;
            }
          });
          throw err;
        });
        setSuspensePromise(promise);
        return promise;
      } : mutate;
      return [fn, state];
    }, [state, mutate, retry, optsRef, setSuspensePromise]);
  };
  return useMutation;
}

exports.createUseMutation = createUseMutation;
