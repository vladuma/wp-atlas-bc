import { GQtyError, doRetry } from 'gqty';
import * as React from 'react';
import { useSuspensePromise, useIsWindowVisible, useSelectionsState, fetchPolicyDefaultResolveOptions, useDeferDispatch, useUpdateEffect, useSubscribeCacheChanges } from '../common.mjs';

function UseTransactionQueryReducer(state, action) {
  switch (action.type) {
    case "loading": {
      if (state.isLoading)
        return state;
      return {
        data: state.data,
        isLoading: true,
        isCalled: true
      };
    }
    case "success": {
      return {
        data: action.data,
        isLoading: false,
        isCalled: true
      };
    }
    case "cache-found": {
      return {
        data: action.data,
        isLoading: state.isLoading,
        isCalled: true
      };
    }
    case "failure": {
      return {
        data: state.data,
        isLoading: false,
        error: action.error,
        isCalled: true
      };
    }
    case "done": {
      if (state.isLoading) {
        return {
          data: state.data,
          isLoading: false,
          isCalled: true
        };
      }
      return state;
    }
  }
}
function InitUseTransactionQueryReducer({
  skip
}) {
  return {
    data: void 0,
    isLoading: skip ? false : true,
    isCalled: false
  };
}
function createUseTransactionQuery(client, {
  defaults: {
    transactionFetchPolicy: defaultFetchPolicy,
    retry: defaultRetry,
    transactionQuerySuspense: defaultSuspense
  }
}) {
  const { resolved, eventHandler, refetch } = client;
  const clientQuery = client.query;
  const useTransactionQuery = function useTransactionQuery2(fn, ...[queryOptions]) {
    var _a, _b, _c, _d;
    const rejectedPromise = React.useRef();
    if (rejectedPromise.current)
      throw rejectedPromise.current;
    const opts = Object.assign({}, queryOptions);
    (_a = opts.fetchPolicy) != null ? _a : opts.fetchPolicy = defaultFetchPolicy;
    (_b = opts.retry) != null ? _b : opts.retry = defaultRetry;
    (_c = opts.suspense) != null ? _c : opts.suspense = defaultSuspense;
    (_d = opts.notifyOnNetworkStatusChange) != null ? _d : opts.notifyOnNetworkStatusChange = true;
    const optsRef = React.useRef(opts);
    optsRef.current = opts;
    const setSuspensePromise = useSuspensePromise(optsRef);
    const { skip, pollInterval = 0, fetchPolicy, variables } = opts;
    const isWindowVisible = useIsWindowVisible({
      lazy: true
    });
    const hookSelections = useSelectionsState();
    const resolveOptions = React.useMemo(() => {
      return fetchPolicyDefaultResolveOptions(fetchPolicy);
    }, [fetchPolicy]);
    const [state, dispatchReducer] = React.useReducer(UseTransactionQueryReducer, opts, InitUseTransactionQueryReducer);
    const dispatch = useDeferDispatch(dispatchReducer);
    const stateRef = React.useRef(state);
    stateRef.current = state;
    const fnRef = React.useRef(fn);
    fnRef.current = fn;
    const isFetching = React.useRef(false);
    const pendingPromise = React.useRef();
    const queryCallback = React.useCallback((resolveOptsArg = {}, fetchPolicyArg = fetchPolicy, cacheChangeCall) => {
      if (skip) {
        return Promise.resolve(dispatch({
          type: "done"
        }));
      }
      stateRef.current.isCalled = true;
      const fn2 = () => fnRef.current(clientQuery, optsRef.current.variables);
      stateRef.current.isLoading = false;
      let instaResolved = false;
      const promise = resolved(fn2, {
        ...resolveOptions,
        ...resolveOptsArg,
        onSelection(selection) {
          hookSelections.add(selection);
        },
        onEmptyResolve() {
          instaResolved = true;
        },
        onCacheData(data) {
          switch (fetchPolicyArg) {
            case "cache-and-network": {
              stateRef.current.isLoading = true;
              dispatch({
                type: "cache-found",
                data
              });
              stateRef.current.data = data;
              return true;
            }
            case "cache-first": {
              instaResolved = true;
              if (cacheChangeCall) {
                dispatch({
                  type: "success",
                  data
                });
              }
              stateRef.current.data = data;
              return false;
            }
            default: {
              return true;
            }
          }
        },
        onNoCacheFound() {
          isFetching.current = true;
          dispatch({
            type: "loading"
          });
          stateRef.current.isLoading = true;
        }
      }).then((data) => {
        var _a2, _b2;
        pendingPromise.current = void 0;
        (_b2 = (_a2 = optsRef.current).onCompleted) == null ? void 0 : _b2.call(_a2, data);
        isFetching.current = false;
        if (stateRef.current.isLoading || stateRef.current.data !== data) {
          dispatch({
            type: "success",
            data
          });
          stateRef.current.data = data;
        }
        stateRef.current.isLoading = false;
      }, (err) => {
        var _a2, _b2;
        pendingPromise.current = void 0;
        isFetching.current = false;
        const error = GQtyError.create(err, useTransactionQuery2);
        (_b2 = (_a2 = optsRef.current).onError) == null ? void 0 : _b2.call(_a2, error);
        dispatch({
          type: "failure",
          error
        });
        stateRef.current.error = error;
        stateRef.current.isLoading = false;
        return error;
      });
      if (instaResolved)
        return;
      pendingPromise.current = promise;
      return promise;
    }, [fetchPolicy, skip, stateRef, resolveOptions, fnRef, dispatch, optsRef]);
    const serializedVariables = React.useMemo(() => {
      return variables ? JSON.stringify(variables) : "";
    }, [variables]);
    const queryCallbackWithPromise = React.useCallback((inlineCall) => {
      var _a2;
      if (skip)
        return;
      const promise = (_a2 = queryCallback()) == null ? void 0 : _a2.then((result) => {
        if (result instanceof GQtyError) {
          if (optsRef.current.retry) {
            doRetry(optsRef.current.retry, {
              async onRetry() {
                var _a3;
                const retryPromise = (_a3 = queryCallback({
                  refetch: true
                })) == null ? void 0 : _a3.then((result2) => {
                  if (result2 instanceof GQtyError)
                    throw result2;
                });
                if (retryPromise) {
                  setSuspensePromise(retryPromise);
                  await retryPromise;
                }
              }
            });
          } else if (optsRef.current.suspense) {
            throw result;
          }
        }
      });
      if (promise) {
        if (inlineCall) {
          Promise.resolve().then(() => {
            setSuspensePromise(promise);
          });
        } else {
          setSuspensePromise(promise);
        }
      }
    }, [queryCallback, skip, setSuspensePromise, optsRef]);
    if (!state.isCalled && !skip) {
      queryCallbackWithPromise(true);
    }
    useUpdateEffect(() => {
      queryCallbackWithPromise();
    }, [queryCallbackWithPromise, serializedVariables]);
    React.useEffect(() => {
      if (skip || pollInterval <= 0)
        return;
      let isMounted = true;
      const interval = setInterval(() => {
        if (isFetching.current)
          return;
        if (!optsRef.current.pollInBackground && !isWindowVisible.ref.current) {
          return;
        }
        isFetching.current = true;
        if (isMounted && optsRef.current.notifyOnNetworkStatusChange)
          dispatch({
            type: "loading"
          });
        const fn2 = () => fnRef.current(clientQuery, optsRef.current.variables);
        (resolveOptions.noCache ? resolved(fn2, resolveOptions) : refetch(fn2)).then((data) => {
          pendingPromise.current = void 0;
          isFetching.current = false;
          if (isMounted)
            dispatch({
              type: "success",
              data
            });
        }, (err) => {
          pendingPromise.current = void 0;
          isFetching.current = false;
          if (isMounted)
            dispatch({
              type: "failure",
              error: GQtyError.create(err, useTransactionQuery2)
            });
        });
      }, pollInterval);
      return () => {
        isMounted = false;
        clearInterval(interval);
      };
    }, [
      pollInterval,
      skip,
      resolveOptions,
      optsRef,
      fnRef,
      dispatch,
      isFetching,
      isWindowVisible
    ]);
    useSubscribeCacheChanges({
      hookSelections,
      eventHandler,
      shouldSubscribe: fetchPolicy !== "no-cache",
      onChange() {
        if (pendingPromise.current)
          return;
        queryCallback({
          refetch: false
        }, "cache-first", true);
      }
    });
    return state;
  };
  return useTransactionQuery;
}

export { createUseTransactionQuery };
