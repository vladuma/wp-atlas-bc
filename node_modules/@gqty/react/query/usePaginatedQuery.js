'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const React = require('react');
const common = require('../common.js');

function UsePaginatedQueryReducer(state, action) {
  switch (action.type) {
    case "loading": {
      if (state.isLoading)
        return state;
      return {
        ...state,
        isLoading: true,
        called: true
      };
    }
    case "cache_found": {
      return {
        data: action.payload,
        args: state.args,
        isLoading: true,
        called: true
      };
    }
    case "data": {
      return {
        data: action.payload,
        args: state.args,
        isLoading: false,
        called: true
      };
    }
    default:
      return state;
  }
}
function InitUsePaginatedQueryReducer(opts) {
  return {
    data: void 0,
    args: opts.initialArgs,
    isLoading: !opts.skip,
    called: false
  };
}
function createUsePaginatedQuery({
  query: clientQuery,
  inlineResolved,
  eventHandler
}, {
  defaults: {
    paginatedQueryFetchPolicy: defaultFetchPolicy,
    paginatedQuerySuspense: defaultSuspense
  }
}) {
  function usePaginatedQuery(fn, opts) {
    var _a, _b, _c, _d;
    const fnRef = React.useRef(fn);
    fnRef.current = fn;
    const optsRef = React.useRef(opts);
    optsRef.current = Object.assign({}, opts);
    (_b = (_a = optsRef.current).fetchPolicy) != null ? _b : _a.fetchPolicy = defaultFetchPolicy;
    (_d = (_c = optsRef.current).suspense) != null ? _d : _c.suspense = defaultSuspense;
    const [state, dispatch] = React.useReducer(UsePaginatedQueryReducer, opts, InitUsePaginatedQueryReducer);
    const hookSelections = common.useSelectionsState();
    const stateRef = React.useRef(state);
    stateRef.current = state;
    const setSuspensePromise = common.useSuspensePromise(optsRef);
    const isMerging = React.useRef(0);
    const fetchMore = React.useCallback((newArgs, fetchPolicy = optsRef.current.fetchPolicy || defaultFetchPolicy) => {
      function mergeData(incomingData2) {
        let mergeResult;
        if (optsRef.current.merge) {
          const params = {
            data: {
              incoming: incomingData2,
              existing: stateRef.current.data
            },
            uniqBy: common.uniqBy,
            sortBy: common.sortBy
          };
          try {
            ++isMerging.current;
            mergeResult = optsRef.current.merge(params);
          } finally {
            Promise.resolve().then(() => --isMerging.current);
          }
        }
        return mergeResult === void 0 ? incomingData2 : mergeResult;
      }
      let args = newArgs !== void 0 ? typeof newArgs === "function" ? stateRef.current.args = newArgs({
        existingData: stateRef.current.data,
        existingArgs: stateRef.current.args
      }) : stateRef.current.args = newArgs : stateRef.current.args;
      const resolvedFn = () => fnRef.current(clientQuery, args, common.coreHelpers);
      const refetch = fetchPolicy !== "cache-first";
      let incomingData = inlineResolved(resolvedFn, {
        onSelection(selection) {
          hookSelections.add(selection);
        },
        refetch,
        onCacheData(data) {
          if (fetchPolicy === "cache-and-network") {
            const payload2 = mergeData(data);
            stateRef.current.data = payload2;
            dispatch({
              type: "cache_found",
              payload: payload2
            });
          }
        }
      });
      if (incomingData instanceof Promise) {
        dispatch({
          type: "loading"
        });
        return incomingData.then((incomingData2) => {
          const payload2 = mergeData(incomingData2);
          stateRef.current.data = payload2;
          dispatch({
            type: "data",
            payload: payload2
          });
          return payload2;
        });
      }
      const payload = mergeData(incomingData);
      stateRef.current.data = payload;
      dispatch({
        type: "data",
        payload
      });
      return payload;
    }, [stateRef, fnRef, dispatch, optsRef, setSuspensePromise]);
    common.useSubscribeCacheChanges({
      hookSelections,
      eventHandler,
      onChange() {
        if (isMerging.current)
          return;
        fetchMore(void 0, "cache-first");
      }
    });
    if (!state.called && !opts.skip) {
      state.called = true;
      const result = fetchMore();
      if (result instanceof Promise) {
        const catchedPromise = result.catch(console.error);
        if (state.data === void 0) {
          Promise.resolve().then(() => {
            setSuspensePromise(catchedPromise);
          });
        }
      }
    }
    return React.useMemo(() => {
      return Object.assign(state, {
        fetchMore
      });
    }, [state, fetchMore]);
  }
  return usePaginatedQuery;
}

exports.createUsePaginatedQuery = createUsePaginatedQuery;
