'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const gqty = require('gqty');
const React = require('react');
const common = require('../common.js');

function initSelectionsState() {
  return new Set();
}
function UseRefetchReducer(state, action) {
  switch (action.type) {
    case "loading": {
      if (state.isLoading)
        return state;
      return {
        isLoading: true
      };
    }
    case "done": {
      return {
        isLoading: false
      };
    }
    case "error": {
      return {
        isLoading: false,
        error: action.error
      };
    }
  }
}
function InitUseRefetchReducer() {
  return {
    isLoading: false
  };
}
function createUseRefetch(client, { defaults: { retry: defaultRetry } }) {
  const { interceptorManager, buildAndFetchSelections, refetch } = client;
  function initInnerState() {
    return {
      watching: true
    };
  }
  const useRefetch = function useRefetch2(refetchOptions) {
    var _a, _b, _c;
    const opts = Object.assign({}, refetchOptions);
    (_a = opts.notifyOnNetworkStatusChange) != null ? _a : opts.notifyOnNetworkStatusChange = true;
    (_b = opts.startWatching) != null ? _b : opts.startWatching = true;
    (_c = opts.retry) != null ? _c : opts.retry = defaultRetry;
    const optsRef = React.useRef(opts);
    optsRef.current = opts;
    const { retry } = opts;
    const innerState = common.useLazyRef(initInnerState);
    innerState.current.watching = opts.startWatching;
    const startWatching = React.useCallback(() => {
      innerState.current.watching = true;
    }, [innerState]);
    const stopWatching = React.useCallback(() => {
      innerState.current.watching = false;
    }, [innerState]);
    const [selections] = React.useState(initSelectionsState);
    const [reducerState, dispatch] = React.useReducer(UseRefetchReducer, void 0, InitUseRefetchReducer);
    const interceptor = interceptorManager.createInterceptor();
    setTimeout(() => {
      interceptorManager.removeInterceptor(interceptor);
    }, 0);
    common.useIsomorphicLayoutEffect(() => {
      interceptorManager.removeInterceptor(interceptor);
    });
    interceptor.selectionAddListeners.add((selection) => {
      if (!innerState.current.watching)
        return;
      selections.add(selection);
    });
    interceptor.selectionCacheListeners.add((selection) => {
      if (!innerState.current.watching)
        return;
      selections.add(selection);
    });
    const refetchCallback = React.useCallback(async (refetchArg) => {
      if (refetchArg !== void 0) {
        if (optsRef.current.notifyOnNetworkStatusChange) {
          dispatch({
            type: "loading"
          });
        }
        try {
          const refetchData = await refetch(refetchArg);
          dispatch({
            type: "done"
          });
          return refetchData;
        } catch (err) {
          const error = gqty.GQtyError.create(err, useRefetch2);
          dispatch({
            type: "error",
            error
          });
          throw error;
        }
      }
      const selectionsToRefetch = Array.from(selections).filter((v) => v.type === gqty.SelectionType.Query);
      if (selectionsToRefetch.length === 0) {
        if (process.env.NODE_ENV !== "production")
          console.warn("Warning! No selections available to refetch!");
        return;
      }
      if (optsRef.current.notifyOnNetworkStatusChange)
        dispatch({
          type: "loading"
        });
      try {
        await buildAndFetchSelections(selectionsToRefetch, "query");
        dispatch({
          type: "done"
        });
      } catch (err) {
        const error = gqty.GQtyError.create(err, useRefetch2);
        dispatch({
          type: "error",
          error
        });
        throw error;
      }
      return;
    }, [selections, dispatch, optsRef]);
    const state = React.useMemo(() => Object.assign(reducerState, {
      startWatching,
      stopWatching
    }), [reducerState, startWatching, stopWatching]);
    return React.useMemo(() => {
      const fn = refetchCallback.bind(void 0);
      const returnValue = Object.assign(retry ? (...args) => {
        return fn(...args).catch((err) => {
          gqty.doRetry(retry, {
            onRetry: () => fn(...args)
          });
          throw err;
        });
      } : fn, state);
      return returnValue;
    }, [refetchCallback, state, retry]);
  };
  return useRefetch;
}

exports.createUseRefetch = createUseRefetch;
