import type { GQtyClient } from 'gqty';
import { CoreHelpers, FetchPolicy, uniqBy, sortBy } from '../common';
import type { ReactClientOptionsWithDefaults } from '../utils';
export declare type PaginatedQueryFetchPolicy = Extract<FetchPolicy, 'cache-first' | 'cache-and-network' | 'network-only'>;
export interface UsePaginatedQueryMergeParams<TData> {
    data: {
        existing: TData | undefined;
        incoming: TData;
    };
    uniqBy: typeof uniqBy;
    sortBy: typeof sortBy;
}
export interface UsePaginatedQueryOptions<TData, TArgs> {
    /**
     * Initial arguments used on first request
     */
    initialArgs: TArgs;
    /**
     * Custom merge function
     */
    merge?: (params: UsePaginatedQueryMergeParams<TData>) => TData | undefined | void;
    /**
     * Fetch Policy behavior
     *
     * If using `cache-and-network` and `merge`, we recomend using the `uniqBy` helper included inside the `merge` parameters.
     */
    fetchPolicy?: PaginatedQueryFetchPolicy;
    /**
     * Skip initial query call
     *
     * @default false
     */
    skip?: boolean;
    /**
     * Activate suspense on first call
     */
    suspense?: boolean;
}
export interface UsePaginatedQueryData<TData, TArgs> {
    /**
     * Query Data
     */
    data: TData | undefined;
    /**
     * Current arguments used in the query
     */
    args: TArgs;
    /**
     * Network fetch is loading
     */
    isLoading: boolean;
    /**
     * Main function to be used
     *
     * If new args are not specified, the previous or initial args are used
     *
     * In the second parameter you can override the `"fetchPolicy"`, for example you can set it to `"network-only"` to do a refetch.
     */
    fetchMore: (
    /**
     * Optional new args. It can receive a function that receives the previous data/args and returns the new args, or the new args directly
     *
     * If not specified or `undefined`, the previous or initial args are used.
     */
    newArgs?: ((data: FetchMoreCallbackArgs<TData, TArgs>) => TArgs) | TArgs | undefined, 
    /**
     * Override hook fetchPolicy
     */
    fetchPolicy?: PaginatedQueryFetchPolicy) => Promise<TData> | TData;
    /**
     * Has the function been called
     */
    called: boolean;
}
export interface FetchMoreCallbackArgs<TData, TArgs> {
    existingData: TData | undefined;
    existingArgs: TArgs;
}
export interface UsePaginatedQuery<GeneratedSchema extends {
    query: object;
    mutation: object;
    subscription: object;
}> {
    <TData, TArgs extends Record<string, any> | string | number | null>(fn: (query: GeneratedSchema['query'], args: TArgs, helpers: CoreHelpers) => TData, options: UsePaginatedQueryOptions<TData, TArgs>): UsePaginatedQueryData<TData, TArgs>;
}
export declare function createUsePaginatedQuery<GeneratedSchema extends {
    query: object;
    mutation: object;
    subscription: object;
}>({ query: clientQuery, inlineResolved, eventHandler, }: GQtyClient<GeneratedSchema>, { defaults: { paginatedQueryFetchPolicy: defaultFetchPolicy, paginatedQuerySuspense: defaultSuspense, }, }: ReactClientOptionsWithDefaults): UsePaginatedQuery<GeneratedSchema>;
