'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const gqty = require('gqty');
const React = require('react');
const common = require('../common.js');

function UseLazyQueryReducer(state, action) {
  switch (action.type) {
    case "loading": {
      if (state.isLoading)
        return state;
      return {
        data: state.data,
        isLoading: true,
        isCalled: true
      };
    }
    case "success": {
      return {
        data: action.data,
        isLoading: false,
        isCalled: true
      };
    }
    case "failure": {
      return {
        data: state.data,
        isLoading: false,
        error: action.error,
        isCalled: true
      };
    }
    case "cache-found": {
      return {
        data: action.data,
        isLoading: state.isLoading,
        isCalled: true
      };
    }
  }
}
function InitUseLazyQueryReducer() {
  return {
    data: void 0,
    isLoading: false,
    isCalled: false
  };
}
function createUseLazyQuery(client, {
  defaults: {
    retry: defaultRetry,
    lazyQuerySuspense: defaultSuspense,
    lazyFetchPolicy: defaultFetchPolicy
  }
}) {
  const { resolved } = client;
  const clientQuery = client.query;
  const useLazyQuery = function useLazyQuery2(fn, opts = {}) {
    var _a, _b;
    const [state, dispatchReducer] = React.useReducer(UseLazyQueryReducer, void 0, InitUseLazyQueryReducer);
    const dispatch = common.useDeferDispatch(dispatchReducer);
    const stateRef = React.useRef(state);
    stateRef.current = state;
    const fnRef = React.useRef(fn);
    fnRef.current = fn;
    const optsRef = React.useRef(opts);
    optsRef.current = Object.assign({}, opts);
    (_b = (_a = optsRef.current).suspense) != null ? _b : _a.suspense = defaultSuspense;
    const setSuspensePromise = common.useSuspensePromise(optsRef);
    const queryFn = React.useCallback(function callback(callbackArgs = {}) {
      var _a2;
      dispatch({
        type: "loading"
      });
      const {
        fn: fnArg,
        args,
        fetchPolicy = (_a2 = optsRef.current.fetchPolicy) != null ? _a2 : defaultFetchPolicy
      } = callbackArgs;
      const refFn = fnRef.current;
      const functionResolve = fnArg ? () => fnArg(clientQuery, args) : refFn ? () => refFn(clientQuery, args) : (() => {
        throw new gqty.GQtyError("You have to specify a function to be resolved", {
          caller: callback
        });
      })();
      const resolveOptions = common.fetchPolicyDefaultResolveOptions(fetchPolicy);
      return resolved(functionResolve, {
        ...resolveOptions,
        onCacheData(data) {
          switch (fetchPolicy) {
            case "cache-and-network": {
              dispatch({
                type: "cache-found",
                data
              });
              stateRef.current.data = data;
              return true;
            }
            default:
              return false;
          }
        }
      }).then((data) => {
        var _a3, _b2;
        (_b2 = (_a3 = optsRef.current).onCompleted) == null ? void 0 : _b2.call(_a3, data);
        dispatch({
          type: "success",
          data
        });
        return data;
      }, (err) => {
        var _a3, _b2;
        const error = gqty.GQtyError.create(err, useLazyQuery2);
        (_b2 = (_a3 = optsRef.current).onError) == null ? void 0 : _b2.call(_a3, error);
        dispatch({
          type: "failure",
          error
        });
        throw error;
      });
    }, [fnRef, dispatch, optsRef]);
    const { retry = defaultRetry } = opts;
    return React.useMemo(() => {
      const fn2 = retry ? (...args) => {
        const promise = queryFn(...args).catch((err) => {
          gqty.doRetry(retry, {
            onRetry: () => {
              const promise2 = queryFn(...args).then(() => {
              });
              setSuspensePromise(promise2);
              return promise2;
            }
          });
          throw err;
        });
        setSuspensePromise(promise);
        return promise;
      } : (...args) => {
        const promise = queryFn(...args);
        setSuspensePromise(promise);
        return promise;
      };
      return [fn2, state];
    }, [state, queryFn, retry, optsRef, setSuspensePromise]);
  };
  return useLazyQuery;
}

exports.createUseLazyQuery = createUseLazyQuery;
