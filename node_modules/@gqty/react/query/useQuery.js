'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const gqty = require('gqty');
const React = require('react');
const common = require('../common.js');

function createUseQuery(client, opts) {
  const {
    suspense: defaultSuspense,
    staleWhileRevalidate: defaultStaleWhileRevalidate
  } = opts.defaults;
  const { scheduler, eventHandler, interceptorManager } = client;
  const clientQuery = client.query;
  const prepareHelpers = {
    prepass: gqty.prepass,
    query: clientQuery
  };
  const errorsMap = scheduler.errors.map;
  const getLastError = () => Array.from(errorsMap.values()).pop();
  const useQuery = function useQuery2({
    suspense = defaultSuspense,
    staleWhileRevalidate = defaultStaleWhileRevalidate,
    onError,
    prepare
  } = {}) {
    const [$state] = React.useState(() => {
      const state = {
        isLoading: true
      };
      const error = getLastError();
      if (error)
        state.error = error;
      return state;
    });
    const { unsubscribe, fetchingPromise } = common.useInterceptSelections({
      staleWhileRevalidate,
      eventHandler,
      interceptorManager,
      scheduler,
      onError,
      updateOnFetchPromise: true
    });
    if (prepare) {
      try {
        prepare(prepareHelpers);
      } catch (err) {
        if (err instanceof Error && Error.captureStackTrace) {
          Error.captureStackTrace(err, useQuery2);
        }
        throw err;
      }
    }
    common.useIsomorphicLayoutEffect(() => {
      return scheduler.errors.subscribeErrors((ev) => {
        switch (ev.type) {
          case "errors_clean":
          case "new_error":
            const error = getLastError();
            if (error) {
              $state.error = error;
            } else {
              delete $state.error;
            }
        }
      });
    }, []);
    common.useIsomorphicLayoutEffect(unsubscribe);
    if (fetchingPromise.current) {
      $state.isLoading = true;
      if (suspense)
        throw fetchingPromise.current;
    } else {
      $state.isLoading = false;
    }
    return React.useMemo(() => {
      const gqtyProxy = Symbol("gqty-proxy");
      return new Proxy(Object.keys(clientQuery).reduce((acum, value) => {
        acum[value] = gqtyProxy;
        return acum;
      }, {
        $state
      }), {
        set(_t, key, value) {
          return Reflect.set(clientQuery, key, value);
        },
        get(_t, key) {
          if (key === "$state")
            return $state;
          return Reflect.get(clientQuery, key);
        }
      });
    }, [$state]);
  };
  return useQuery;
}

exports.createUseQuery = createUseQuery;
