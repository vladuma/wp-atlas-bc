'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const gqty = require('gqty');
const React = require('react');

function useOnFirstMount(fn) {
  const isFirstMount = React.useRef(true);
  if (isFirstMount.current) {
    isFirstMount.current = false;
    fn();
  }
}
const IS_BROWSER = typeof window !== "undefined";
const useIsomorphicLayoutEffect = IS_BROWSER ? React.useLayoutEffect : React.useEffect;
const updateReducer = (num) => (num + 1) % 1e6;
function useForceUpdate({ doTimeout } = {}) {
  const [, update] = React.useReducer(updateReducer, 0);
  const wasCalled = React.useRef(false);
  React.useEffect(() => {
    wasCalled.current = false;
  });
  return React.useMemo(() => {
    return Object.assign(() => {
      if (wasCalled.current)
        return;
      wasCalled.current = true;
      if (doTimeout) {
        setTimeout(update, 0);
      } else {
        Promise.resolve().then(update);
      }
    }, {
      wasCalled
    });
  }, [update, wasCalled, doTimeout]);
}
const InitSymbol = Symbol();
function useLazyRef(initialValFunc) {
  const ref = React.useRef(InitSymbol);
  if (ref.current === InitSymbol) {
    ref.current = initialValFunc();
  }
  return ref;
}
const useUpdateEffect = (effect, deps) => {
  const firstEffectCall = React.useRef(true);
  React.useEffect(() => {
    if (firstEffectCall.current) {
      firstEffectCall.current = false;
    } else
      return effect();
  }, deps);
};
function useIsRendering() {
  const isRendering = React.useRef(true);
  isRendering.current = true;
  useIsomorphicLayoutEffect(() => {
    isRendering.current = false;
  });
  return isRendering;
}
function useIsMounted() {
  const isMounted = React.useRef(true);
  useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
}
function useDeferDispatch(dispatchFn) {
  const isMounted = useIsMounted();
  const isRendering = useIsRendering();
  const pendingDispatch = React.useRef(false);
  React.useEffect(() => {
    if (pendingDispatch.current) {
      for (const fn of pendingDispatch.current) {
        fn();
      }
      pendingDispatch.current = false;
    }
  });
  return React.useCallback((...args) => {
    if (isRendering.current) {
      if (pendingDispatch.current) {
        pendingDispatch.current.push(() => {
          if (isMounted.current)
            dispatchFn(...args);
        });
      }
      pendingDispatch.current = [
        () => {
          if (isMounted.current)
            dispatchFn(...args);
        }
      ];
    } else if (isMounted.current) {
      dispatchFn(...args);
    }
  }, [dispatchFn, isRendering, pendingDispatch, isMounted]);
}
const noCacheResolveOptions = {
  noCache: true
};
const refetchResolveOptions = {
  refetch: true
};
const emptyResolveOptions = {};
function fetchPolicyDefaultResolveOptions(fetchPolicy) {
  switch (fetchPolicy) {
    case "no-cache": {
      return noCacheResolveOptions;
    }
    case "cache-and-network":
    case "network-only": {
      return refetchResolveOptions;
    }
    case "cache-first":
    default: {
      return emptyResolveOptions;
    }
  }
}
function useBuildSelections(argSelections, getProxySelection, caller) {
  const buildSelections = React.useCallback((selectionsSet) => {
    selectionsSet.clear();
    if (!argSelections)
      return;
    try {
      for (const filterValue of argSelections) {
        let selection;
        if (filterValue instanceof gqty.Selection) {
          selectionsSet.add(filterValue);
        } else if (selection = getProxySelection(filterValue)) {
          selectionsSet.add(selection);
        }
      }
    } catch (err) {
      if (err instanceof Error && Error.captureStackTrace) {
        Error.captureStackTrace(err, caller);
      }
      throw err;
    }
  }, [argSelections]);
  const [selections] = React.useState(() => {
    const selectionsSet = new Set();
    buildSelections(selectionsSet);
    return selectionsSet;
  });
  useUpdateEffect(() => {
    buildSelections(selections);
  }, [buildSelections, selections]);
  return {
    selections,
    hasSpecifiedSelections: argSelections != null
  };
}
function toSetIfNeeded(list) {
  return Array.isArray(list) ? new Set(list) : list;
}
function isSelectionIncluded(selection, selectionList) {
  const setSelectionList = toSetIfNeeded(selectionList);
  if (setSelectionList.has(selection))
    return true;
  for (const listValue of selectionList) {
    if (setSelectionList.has(listValue))
      return true;
  }
  return false;
}
function isAnySelectionIncluded(selectionsToCheck, selectionsList) {
  const setSelectionList = toSetIfNeeded(selectionsList);
  for (const selection of selectionsToCheck) {
    if (isSelectionIncluded(selection, setSelectionList))
      return true;
  }
  return false;
}
function isAnySelectionIncludedInMatrix(selectionsToCheck, selectionsMatrix) {
  const selectionsToCheckSet = toSetIfNeeded(selectionsToCheck);
  for (const group of selectionsMatrix) {
    if (isAnySelectionIncluded(selectionsToCheckSet, group))
      return true;
  }
  return false;
}
function initSelectionsState() {
  return new Set();
}
function useSelectionsState() {
  const [selections] = React.useState(initSelectionsState);
  return selections;
}
function useSubscribeCacheChanges({
  hookSelections,
  eventHandler,
  onChange,
  shouldSubscribe = true
}) {
  const onChangeCalled = React.useRef(false);
  useIsomorphicLayoutEffect(() => {
    onChangeCalled.current = false;
  });
  useIsomorphicLayoutEffect(() => {
    if (!shouldSubscribe)
      return;
    let isMounted = true;
    const unsubscribeFetch = eventHandler.onFetchSubscribe((fetchPromise, promiseSelections) => {
      if (onChangeCalled.current || !promiseSelections.some((selection) => hookSelections.has(selection))) {
        return;
      }
      onChangeCalled.current = true;
      fetchPromise.then(() => {
        if (isMounted)
          Promise.resolve(fetchPromise).then(onChange);
      }, () => {
      });
    });
    const unsubscribeCache = eventHandler.onCacheChangeSubscribe(({ selection }) => {
      if (isMounted && !onChangeCalled.current && hookSelections.has(selection)) {
        onChangeCalled.current = true;
        Promise.resolve().then(onChange);
      }
    });
    return () => {
      isMounted = false;
      unsubscribeFetch();
      unsubscribeCache();
    };
  }, [shouldSubscribe, hookSelections, eventHandler, onChange]);
}
function hasEnabledStaleWhileRevalidate(staleWhileRevalidate) {
  return typeof staleWhileRevalidate === "boolean" ? staleWhileRevalidate : true;
}
function useInterceptSelections({
  interceptorManager: {
    globalInterceptor,
    createInterceptor,
    removeInterceptor
  },
  staleWhileRevalidate = false,
  scheduler,
  eventHandler,
  onError,
  updateOnFetchPromise
}) {
  const hookSelections = useSelectionsState();
  const forceUpdate = useDeferDispatch(useForceUpdate());
  const fetchingPromise = React.useRef(null);
  const interceptor = createInterceptor();
  const enabledStaleWhileRevalidate = hasEnabledStaleWhileRevalidate(staleWhileRevalidate);
  const cacheRefetchSelections = enabledStaleWhileRevalidate ? new Set() : null;
  interceptor.selectionCacheRefetchListeners.add((selection) => {
    if (cacheRefetchSelections)
      cacheRefetchSelections.add(selection);
    hookSelections.add(selection);
  });
  useIsomorphicLayoutEffect(() => {
    if (enabledStaleWhileRevalidate && (cacheRefetchSelections == null ? void 0 : cacheRefetchSelections.size)) {
      for (const selection of cacheRefetchSelections) {
        globalInterceptor.addSelectionCacheRefetch(selection);
      }
    }
  }, [staleWhileRevalidate, enabledStaleWhileRevalidate]);
  interceptor.selectionAddListeners.add((selection) => {
    hookSelections.add(selection);
  });
  interceptor.selectionCacheListeners.add((selection) => {
    hookSelections.add(selection);
  });
  const deferredCall = React.useRef(null);
  React.useEffect(() => {
    if (deferredCall.current) {
      deferredCall.current();
      deferredCall.current = null;
    }
  });
  const isRendering = useIsRendering();
  const unsubscribeResolve = scheduler.subscribeResolve((promise, selection) => {
    if (fetchingPromise.current === null && deferredCall.current === null && hookSelections.has(selection)) {
      const newPromise = new Promise((resolve) => {
        promise.then(({ error }) => {
          fetchingPromise.current = null;
          if (error && onError)
            onError(error);
          Promise.resolve().then(forceUpdate);
          resolve();
        });
      });
      fetchingPromise.current = newPromise;
      if (updateOnFetchPromise) {
        if (enabledStaleWhileRevalidate && isRendering.current) {
          deferredCall.current = forceUpdate;
        } else {
          deferredCall.current = null;
          forceUpdate();
        }
      }
    }
  });
  function unsubscribe() {
    unsubscribeResolve();
    removeInterceptor(interceptor);
  }
  Promise.resolve().then(unsubscribe);
  useSubscribeCacheChanges({
    hookSelections,
    eventHandler,
    onChange() {
      if (!fetchingPromise.current)
        forceUpdate();
    }
  });
  return { fetchingPromise, unsubscribe };
}
function useSuspensePromise(optsRef) {
  let [promise, setPromiseState] = React.useState();
  const isMounted = useIsMounted();
  const setPromise = React.useCallback((newPromise, inlineThrow) => {
    if (promise || !optsRef.current.suspense || !isMounted.current)
      return;
    function clearPromise() {
      if (isMounted.current)
        setPromiseState();
    }
    const promiseValue = promise = newPromise.then(clearPromise, clearPromise);
    setPromiseState(promiseValue);
    if (inlineThrow)
      throw promiseValue;
  }, [setPromiseState, optsRef]);
  if (promise)
    throw promise;
  return setPromise;
}
const coreHelpers = {
  prepass: gqty.prepass,
  getFields: gqty.getFields,
  getArrayFields: gqty.getArrayFields,
  selectFields: gqty.selectFields,
  castNotSkeleton: gqty.castNotSkeleton,
  castNotSkeletonDeep: gqty.castNotSkeletonDeep
};
function uniqBy(list, cb) {
  const uniqList = new Map();
  for (const value of list) {
    let key = cb ? cb(value) : value;
    if (uniqList.has(key))
      continue;
    uniqList.set(key, value);
  }
  return Array.from(uniqList.values());
}
const compare = (a, b) => a < b ? -1 : a > b ? 1 : 0;
function sortBy(list, cb, order = "asc") {
  const orderedList = Array.from(list);
  orderedList.sort((a, b) => compare(cb(a), cb(b)));
  if (order === "desc")
    orderedList.reverse();
  return orderedList;
}
const useIsWindowVisible = ({ lazy } = {}) => {
  const [isVisible, setIsVisible] = React.useState(true);
  const ref = React.useRef(true);
  React.useEffect(() => {
    const onVisibilityChange = () => {
      const isVisible2 = document.visibilityState === "visible";
      ref.current = isVisible2;
      !lazy && setIsVisible(isVisible2);
    };
    onVisibilityChange();
    document.addEventListener("visibilitychange", onVisibilityChange);
    return () => {
      document.removeEventListener("visibilitychange", onVisibilityChange);
    };
  }, [setIsVisible, lazy]);
  return React.useMemo(() => {
    return {
      isVisible,
      ref
    };
  }, [isVisible, ref]);
};

exports.IS_BROWSER = IS_BROWSER;
exports.coreHelpers = coreHelpers;
exports.fetchPolicyDefaultResolveOptions = fetchPolicyDefaultResolveOptions;
exports.isAnySelectionIncluded = isAnySelectionIncluded;
exports.isAnySelectionIncludedInMatrix = isAnySelectionIncludedInMatrix;
exports.isSelectionIncluded = isSelectionIncluded;
exports.sortBy = sortBy;
exports.toSetIfNeeded = toSetIfNeeded;
exports.uniqBy = uniqBy;
exports.useBuildSelections = useBuildSelections;
exports.useDeferDispatch = useDeferDispatch;
exports.useForceUpdate = useForceUpdate;
exports.useInterceptSelections = useInterceptSelections;
exports.useIsMounted = useIsMounted;
exports.useIsRendering = useIsRendering;
exports.useIsWindowVisible = useIsWindowVisible;
exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;
exports.useLazyRef = useLazyRef;
exports.useOnFirstMount = useOnFirstMount;
exports.useSelectionsState = useSelectionsState;
exports.useSubscribeCacheChanges = useSubscribeCacheChanges;
exports.useSuspensePromise = useSuspensePromise;
exports.useUpdateEffect = useUpdateEffect;
