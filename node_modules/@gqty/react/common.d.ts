import { castNotSkeleton, castNotSkeletonDeep, getArrayFields, getFields, GQtyError, prepass, ResolveOptions, selectFields, Selection } from 'gqty';
import type { ProxyAccessor } from 'gqty/Cache';
import type { EventHandler } from 'gqty/Events';
import type { InterceptorManager } from 'gqty/Interceptor';
import type { Scheduler } from 'gqty/Scheduler';
import * as React from 'react';
export declare function useOnFirstMount(fn: () => void): void;
export declare const IS_BROWSER: boolean;
export declare const useIsomorphicLayoutEffect: typeof React.useLayoutEffect;
export declare function useForceUpdate({ doTimeout }?: {
    doTimeout?: boolean;
}): (() => void) & {
    wasCalled: React.MutableRefObject<boolean>;
};
export declare function useLazyRef<T>(initialValFunc: () => T): React.MutableRefObject<T>;
export declare const useUpdateEffect: typeof React.useEffect;
export declare function useIsRendering(): React.MutableRefObject<boolean>;
export declare function useIsMounted(): React.MutableRefObject<boolean>;
export declare function useDeferDispatch<F extends (...args: any[]) => void>(dispatchFn: F): F;
export declare type FetchPolicy = 'cache-and-network' | 'cache-first' | 'network-only' | 'no-cache';
export declare function fetchPolicyDefaultResolveOptions(fetchPolicy: FetchPolicy | undefined): ResolveOptions<unknown>;
export declare type BuildSelections<T> = (Selection | T)[];
export declare function useBuildSelections(argSelections: BuildSelections<never> | null | undefined, getProxySelection: (proxy: ProxyAccessor) => Selection | undefined, caller: Function): {
    selections: Set<Selection>;
    hasSpecifiedSelections: boolean;
};
export declare type List<T> = Set<T> | Array<T>;
export declare function toSetIfNeeded<T>(list: List<T>): Set<T>;
export declare function isSelectionIncluded(selection: Selection, selectionList: List<Selection>): boolean;
export declare function isAnySelectionIncluded(selectionsToCheck: List<Selection>, selectionsList: List<Selection>): boolean;
export declare function isAnySelectionIncludedInMatrix(selectionsToCheck: List<Selection>, selectionsMatrix: List<List<Selection>>): boolean;
export declare function useSelectionsState(): Set<Selection>;
export declare function useSubscribeCacheChanges({ hookSelections, eventHandler, onChange, shouldSubscribe, }: {
    hookSelections: Set<Selection>;
    eventHandler: EventHandler;
    onChange: () => void;
    shouldSubscribe?: boolean;
}): void;
export declare function useInterceptSelections({ interceptorManager: { globalInterceptor, createInterceptor, removeInterceptor, }, staleWhileRevalidate, scheduler, eventHandler, onError, updateOnFetchPromise, }: {
    staleWhileRevalidate: boolean | object | number | string | null;
    interceptorManager: InterceptorManager;
    scheduler: Scheduler;
    eventHandler: EventHandler;
    onError: OnErrorHandler | undefined;
    updateOnFetchPromise?: boolean;
}): {
    fetchingPromise: React.MutableRefObject<Promise<void> | null>;
    unsubscribe: () => void;
};
export declare function useSuspensePromise(optsRef: {
    current: {
        suspense?: boolean;
    };
}): (promise: Promise<unknown>, inlineThrow?: boolean | undefined) => void;
export declare type OnErrorHandler = (error: GQtyError) => void;
export interface CoreHelpers {
    prepass: typeof prepass;
    getFields: typeof getFields;
    getArrayFields: typeof getArrayFields;
    selectFields: typeof selectFields;
    castNotSkeleton: typeof castNotSkeleton;
    castNotSkeletonDeep: typeof castNotSkeletonDeep;
}
export declare const coreHelpers: CoreHelpers;
export declare function uniqBy<TNode>(list: TNode[], cb?: (node: TNode) => unknown): TNode[];
export declare function sortBy<TNode>(list: TNode[], cb: (node: TNode) => number | string, order?: 'asc' | 'desc'): TNode[];
export declare const useIsWindowVisible: ({ lazy }?: {
    lazy?: boolean | undefined;
}) => {
    isVisible: boolean;
    ref: React.MutableRefObject<boolean>;
};
