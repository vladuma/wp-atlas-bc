'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const React = require('react');
const common = require('../common.js');
const utils = require('../utils.js');

function createUseMetaState(client) {
  const scheduler = client.scheduler;
  const {
    accessorCache: { getProxySelection }
  } = client;
  const errorsMap = scheduler.errors.map;
  const defaultEmptyOpts = {};
  const useMetaState = function useMetaState2(opts = defaultEmptyOpts) {
    const {
      hasSpecifiedSelections: hasFilterSelections,
      selections: selectionsToFilter
    } = common.useBuildSelections(opts.filterSelections, getProxySelection, useMetaState2);
    const [promisesInFly] = React.useState(() => {
      return new Set();
    });
    const isMountedRef = React.useRef(true);
    React.useEffect(() => {
      return () => {
        isMountedRef.current = false;
      };
    }, []);
    const getState = React.useCallback((isMounted = isMountedRef) => {
      let isFetching;
      if (scheduler.pendingSelectionsGroups.size) {
        if (hasFilterSelections) {
          isFetching = common.isAnySelectionIncludedInMatrix(selectionsToFilter, scheduler.pendingSelectionsGroups);
        } else {
          isFetching = true;
        }
        if (isFetching && scheduler.pendingSelectionsGroupsPromises.size) {
          Promise.all(scheduler.pendingSelectionsGroupsPromises.values()).finally(() => setStateIfChanged(isMounted));
        }
      } else {
        isFetching = false;
      }
      let errors;
      if (hasFilterSelections) {
        const errorsSet = new Set();
        selectionsToFilter.forEach((selection) => {
          const error = errorsMap.get(selection);
          if (error)
            errorsSet.add(error);
        });
        if (errorsSet.size)
          errors = Array.from(errorsSet);
      } else if (errorsMap.size) {
        errors = Array.from(new Set(errorsMap.values()));
      }
      return errors ? { isFetching, errors } : { isFetching };
    }, [hasFilterSelections, selectionsToFilter]);
    const setStateIfChanged = React.useCallback(function setStateIfChanged2(isMounted) {
      if (!isMounted.current)
        return;
      const prevState = stateRef.current;
      const newState = getState(isMounted);
      if (prevState.isFetching !== newState.isFetching || !utils.areArraysEqual(prevState.errors, newState.errors)) {
        stateRef.current = newState;
        setTimeout(() => {
          if (isMounted.current)
            setState(newState);
        }, 0);
      }
    }, []);
    const [state, setState] = React.useState(getState);
    const stateRef = React.useRef(state);
    stateRef.current = state;
    const optsRef = React.useRef(opts);
    optsRef.current = opts;
    common.useIsomorphicLayoutEffect(() => {
      const isMounted = { current: true };
      const unsubscribeIsFetching = scheduler.subscribeResolve((promise, selection) => {
        var _a, _b;
        if (promisesInFly.has(promise))
          return;
        if (hasFilterSelections && !common.isSelectionIncluded(selection, selectionsToFilter)) {
          return;
        }
        if (promisesInFly.size === 0)
          (_b = (_a = optsRef.current).onStartFetching) == null ? void 0 : _b.call(_a);
        promisesInFly.add(promise);
        setStateIfChanged(isMounted);
        promise.then(() => {
          var _a2, _b2;
          promisesInFly.delete(promise);
          if (promisesInFly.size === 0)
            (_b2 = (_a2 = optsRef.current).onDoneFetching) == null ? void 0 : _b2.call(_a2);
          setStateIfChanged(isMounted);
        });
      });
      const unsubscribeErrors = scheduler.errors.subscribeErrors((data) => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        switch (data.type) {
          case "new_error": {
            if (hasFilterSelections) {
              if (common.isAnySelectionIncluded(selectionsToFilter, data.selections))
                (_b = (_a = optsRef.current).onError) == null ? void 0 : _b.call(_a, {
                  newError: data.newError,
                  selections: data.selections,
                  isLastTry: data.isLastTry
                });
              else
                return;
            } else {
              (_d = (_c = optsRef.current).onError) == null ? void 0 : _d.call(_c, {
                newError: data.newError,
                selections: data.selections,
                isLastTry: data.isLastTry
              });
            }
            break;
          }
          case "retry": {
            if (hasFilterSelections) {
              if (common.isAnySelectionIncluded(selectionsToFilter, data.selections)) {
                (_f = (_e = optsRef.current).onRetry) == null ? void 0 : _f.call(_e, {
                  retryPromise: data.retryPromise,
                  selections: data.selections
                });
                data.retryPromise.finally(() => {
                  setTimeout(() => {
                    setStateIfChanged(isMounted);
                  }, 0);
                });
              }
            } else {
              (_h = (_g = optsRef.current).onRetry) == null ? void 0 : _h.call(_g, {
                retryPromise: data.retryPromise,
                selections: data.selections
              });
              data.retryPromise.finally(() => {
                setTimeout(() => {
                  setStateIfChanged(isMounted);
                }, 0);
              });
            }
            break;
          }
        }
        setStateIfChanged(isMounted);
      });
      return () => {
        isMounted.current = false;
        unsubscribeIsFetching();
        unsubscribeErrors();
      };
    }, [getState, hasFilterSelections, setState, optsRef, selectionsToFilter]);
    return state;
  };
  return useMetaState;
}

exports.createUseMetaState = createUseMetaState;
