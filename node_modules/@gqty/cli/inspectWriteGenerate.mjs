import { existsSync, promises } from 'fs';
import { buildClientSchema, buildSchema } from 'graphql';
import { resolve } from 'path';
import { defaultConfig, gqtyConfigPromise, DUMMY_ENDPOINT } from './config.mjs';

async function inspectWriteGenerate({
  endpoint,
  destination,
  generateOptions,
  cli,
  headers,
  transformSchemaOptions
} = {}) {
  if (destination) {
    defaultConfig.destination = destination;
  }
  if (endpoint) {
    defaultConfig.introspection.endpoint = endpoint;
  } else if (existsSync(resolve("./schema.gql"))) {
    endpoint = "./schema.gql";
    defaultConfig.introspection.endpoint = endpoint;
  } else {
    const { config, filepath } = await gqtyConfigPromise;
    const configIntrospectionEndpoint = config.introspection && config.introspection.endpoint;
    if (configIntrospectionEndpoint && configIntrospectionEndpoint !== DUMMY_ENDPOINT) {
      endpoint = configIntrospectionEndpoint;
    } else {
      console.error(`
Please modify "${filepath.endsWith("package.json") ? "gqty" : "config"}.introspection.endpoint" in: "${filepath}".`);
      throw Error("ERROR: No introspection endpoint specified in configuration file.");
    }
  }
  if (!destination) {
    const configDestination = (await gqtyConfigPromise).config.destination;
    destination = configDestination || defaultConfig.destination;
  }
  destination = resolve(destination);
  const genOptions = Object.assign({}, generateOptions);
  let schema;
  defaultConfig.introspection.endpoint = endpoint;
  defaultConfig.introspection.headers = headers || {};
  if (endpoint.startsWith("http://") || endpoint.startsWith("https://")) {
    schema = await (await import('./introspection.mjs')).getRemoteSchema(endpoint, {
      headers
    });
  } else {
    defaultConfig.introspection.endpoint = DUMMY_ENDPOINT;
    if (existsSync(endpoint)) {
      const file = await promises.readFile(endpoint, {
        encoding: "utf-8"
      });
      if (endpoint.endsWith(".json")) {
        const parsedFile = JSON.parse(file);
        let dataField;
        if (typeof parsedFile === "object") {
          if ("data" in parsedFile && parsedFile.data) {
            dataField = parsedFile.data;
          } else if ("__schema" in parsedFile) {
            dataField = parsedFile;
          }
        }
        if (!(typeof dataField === "object"))
          throw Error('Invalid JSON introspection result, expected "__schema" or "data.__schema" field.');
        schema = buildClientSchema(dataField);
      } else {
        schema = buildSchema(file);
      }
    } else {
      throw Error(`File "${endpoint}" doesn't exists. If you meant to inspect a GraphQL API, make sure to put http:// or https:// in front of it.`);
    }
  }
  const generatedPath = await (await import('./writeGenerate.mjs')).writeGenerate(schema, destination, genOptions, async (existingFile) => {
    var _a, _b;
    const subscriptions = (_a = genOptions.subscriptions) != null ? _a : (await gqtyConfigPromise).config.subscriptions;
    const react = (_b = genOptions.react) != null ? _b : (await gqtyConfigPromise).config.react;
    const advice = `
If you meant to change this, please remove "${destination}" and re-run code generation.`;
    if (subscriptions) {
      if (!existingFile.includes("createSubscriptionsClient")) {
        console.warn(`[Warning] You've changed the option "subscriptions" to 'true', which is different from your existing "${destination}".` + advice);
      }
    }
    if (react) {
      if (!existingFile.includes("createReactClient")) {
        console.warn(`[Warning] You've changed the option "react" to 'true', which is different from your existing "${destination}".` + advice);
      }
    }
    if (existingFile.includes("export const {")) {
      console.warn(`[Warning] To prevent possible bundling issues, it's recommended to change the export syntax from "export const { query, ... } = client;" to "const { query, ... } = client; export { query, ... };"`);
    }
  }, transformSchemaOptions);
  if (cli) {
    console.log("Code generated successfully at " + generatedPath);
  }
}

export { inspectWriteGenerate };
