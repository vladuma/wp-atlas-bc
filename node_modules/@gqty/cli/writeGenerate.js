'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const fs = require('fs');
const mkdirp = require('mkdirp');
const path = require('path');
const config = require('./config.js');
const generate = require('./generate.js');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

const mkdirp__default = /*#__PURE__*/_interopDefault(mkdirp);

async function writeClientCode({
  destinationPath,
  clientCode,
  onExistingFileConflict
}) {
  if (fs.existsSync(destinationPath)) {
    if (onExistingFileConflict) {
      const existingFile = await fs.promises.readFile(destinationPath, {
        encoding: "utf-8"
      });
      onExistingFileConflict(existingFile);
    }
    return;
  }
  await fs.promises.writeFile(destinationPath, clientCode, {
    encoding: "utf-8"
  });
}
function waitFunctions(...fns) {
  return Promise.all(fns.map((fn) => fn()));
}
async function writeSchemaCode({
  schemaCode,
  destinationPath,
  isJavascriptOutput,
  javascriptSchemaCode
}) {
  await waitFunctions(async () => {
    const schemaPath = path.resolve(path.dirname(destinationPath), isJavascriptOutput ? "./schema.generated.d.ts" : "./schema.generated.ts");
    if (fs.existsSync(schemaPath)) {
      const existingCode = await fs.promises.readFile(schemaPath, {
        encoding: "utf-8"
      });
      if (existingCode === schemaCode)
        return;
    }
    await fs.promises.writeFile(schemaPath, schemaCode, {
      encoding: "utf-8"
    });
  }, async () => {
    if (isJavascriptOutput) {
      const schemaPath = path.resolve(path.dirname(destinationPath), "./schema.generated.js");
      if (fs.existsSync(schemaPath)) {
        const existingCode = await fs.promises.readFile(schemaPath, {
          encoding: "utf-8"
        });
        if (existingCode === javascriptSchemaCode)
          return;
      }
      await fs.promises.writeFile(schemaPath, javascriptSchemaCode, {
        encoding: "utf-8"
      });
    }
  });
}
async function writeGenerate(schema, destinationPath, generateOptions = {}, onExistingFileConflict, transformsGenerate) {
  var _a, _b;
  const isJavascriptOutput = (_b = (_a = generateOptions.javascriptOutput) != null ? _a : (await config.gqtyConfigPromise).config.javascriptOutput) != null ? _b : config.defaultConfig.javascriptOutput;
  if (isJavascriptOutput) {
    if (!destinationPath.endsWith(".js")) {
      const err = Error('You have to specify the ".js" extension, instead, it received: "' + destinationPath + '"');
      Error.captureStackTrace(err, writeGenerate);
      throw err;
    }
  } else if (!destinationPath.endsWith(".ts")) {
    const err = Error('You have to specify the ".ts" extension, instead, it received: "' + destinationPath + '"');
    Error.captureStackTrace(err, writeGenerate);
    throw err;
  }
  destinationPath = path.resolve(destinationPath);
  const [{ clientCode, schemaCode, javascriptSchemaCode }] = await Promise.all([
    generate.generate(schema, generateOptions, transformsGenerate),
    mkdirp__default["default"](path.dirname(destinationPath))
  ]);
  await Promise.all([
    writeClientCode({ clientCode, destinationPath, onExistingFileConflict }),
    writeSchemaCode({
      schemaCode,
      destinationPath,
      isJavascriptOutput,
      javascriptSchemaCode
    })
  ]);
  return destinationPath;
}

exports.writeGenerate = writeGenerate;
