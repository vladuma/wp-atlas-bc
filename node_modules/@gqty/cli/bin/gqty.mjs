#!/usr/bin/env node
import prettier from 'prettier';
import { cosmiconfig } from 'cosmiconfig';
import { promises, existsSync } from 'fs';
import { createRequire } from 'module';
import { resolve, dirname } from 'path';
import { fetch } from 'cross-fetch';
import { buildClientSchema, buildSchema, lexicographicSortSchema, parse, isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, print, isNullableType } from 'graphql';
import { wrapSchema, introspectSchema } from '@graphql-tools/wrap';
import { codegen } from '@graphql-codegen/core';
import * as typescriptPlugin from '@graphql-codegen/typescript';
import { printSchemaWithDirectives } from '@graphql-tools/utils';
import { SchemaUnionsKey, parseSchemaType } from 'gqty';
import sortBy from 'lodash/sortBy.js';
import mkdirp from 'mkdirp';
import { program } from 'commander';

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/innerState.ts
var __innerState;
var init_innerState = __esm({
  "src/innerState.ts"() {
    __innerState = {
      isCLI: false
    };
  }
});

// src/prettier.ts
var prettier_exports = {};
__export(prettier_exports, {
  formatPrettier: () => formatPrettier
});
function formatPrettier(defaultOptions) {
  const configPromise = commonConfig.then((config) => Object.assign({}, config, defaultOptions));
  return {
    async format(input) {
      return prettierFormat(input, await configPromise);
    }
  };
}
var prettierFormat, resolveConfig, commonConfig;
var init_prettier = __esm({
  "src/prettier.ts"() {
    ({ format: prettierFormat, resolveConfig } = prettier);
    commonConfig = resolveConfig(process.cwd());
  }
});
function isPlainObject(v) {
  return v != null && typeof v === "object" && !Array.isArray(v);
}
function isStringRecord(v) {
  return isPlainObject(v) && Object.values(v).every((v2) => typeof v2 === "string");
}
function warnConfig(fieldName, invalidValue, expectedValue, defaultValue) {
  console.warn(`Warning, invalid config ${fieldName}, got: ${JSON.stringify(invalidValue)}, expected ${expectedValue}. ${JSON.stringify(defaultValue)} used instead.`);
}
function getValidConfig(v) {
  if (isPlainObject(v)) {
    const newConfig = {};
    if (typeof v.javascriptOutput === "boolean") {
      newConfig.javascriptOutput = v.javascriptOutput;
    }
    for (const [key, value] of Object.entries(v)) {
      if (value === void 0)
        continue;
      switch (key) {
        case "destination":
        case "preImport": {
          if (typeof value === "string") {
            newConfig[key] = value;
          } else {
            warnConfig(key, value, "string", defaultConfig[key]);
          }
          break;
        }
        case "javascriptOutput":
        case "react":
        case "subscriptions":
        case "enumsAsStrings": {
          if (typeof value === "boolean") {
            newConfig[key] = value;
          } else {
            warnConfig(key, value, "boolean", defaultConfig[key]);
          }
          break;
        }
        case "scalarTypes": {
          if (isStringRecord(value)) {
            newConfig[key] = value;
          } else {
            warnConfig(key, value, '"object of strings"', defaultConfig[key]);
          }
          break;
        }
        case "introspection": {
          if (isPlainObject(value)) {
            const introspectionOptions = {};
            for (const [introspectionKey, introspectionValue] of Object.entries(value)) {
              if (introspectionValue === void 0)
                continue;
              switch (introspectionKey) {
                case "endpoint": {
                  if (typeof introspectionValue === "string") {
                    introspectionOptions[introspectionKey] = introspectionValue;
                  } else {
                    warnConfig(`${key}.${introspectionKey}`, introspectionValue, "string", defaultConfig.introspection.endpoint);
                  }
                  break;
                }
                case "headers": {
                  if (isStringRecord(introspectionValue)) {
                    introspectionOptions[introspectionKey] = introspectionValue;
                  } else {
                    warnConfig(`${key}.${introspectionKey}`, introspectionValue, '"object of strings"', defaultConfig.introspection.headers);
                  }
                  break;
                }
                default: {
                  console.warn(`Warning, invalid and unused config property "${key}.${introspectionKey}": ${JSON.stringify(value)}`);
                }
              }
            }
            newConfig[key] = introspectionOptions;
          } else {
            warnConfig(key, value, "object", defaultConfig[key]);
          }
          break;
        }
        default:
          console.warn(`Warning, invalid and unused config property "${key}": ${JSON.stringify(value)}`);
      }
    }
    return newConfig;
  } else {
    console.warn("Invalid config, using instead: " + JSON.stringify(defaultConfig, null, 2));
    return defaultConfig;
  }
}
var cjsRequire, DUMMY_ENDPOINT, defaultConfig, defaultFilePath, defaultGQtyConfig, gqtyConfigPromise;
var init_config = __esm({
  "src/config.ts"() {
    init_innerState();
    cjsRequire = globalThis.require || createRequire(import.meta.url);
    DUMMY_ENDPOINT = "SPECIFY_ENDPOINT_OR_SCHEMA_FILE_PATH_HERE";
    defaultConfig = {
      react: (() => {
        try {
          cjsRequire.resolve("react");
          return true;
        } catch (err) {
        }
        return false;
      })(),
      scalarTypes: {
        DateTime: "string"
      },
      introspection: {
        endpoint: DUMMY_ENDPOINT,
        headers: {}
      },
      destination: "./src/gqty/index.ts",
      subscriptions: false,
      javascriptOutput: false,
      enumsAsStrings: false,
      preImport: ""
    };
    defaultFilePath = resolve(process.cwd(), "gqty.config.cjs");
    defaultGQtyConfig = {
      filepath: defaultFilePath,
      config: defaultConfig
    };
    gqtyConfigPromise = new Promise(async (resolve4) => {
      try {
        const cjsLoader = (filePath) => {
          return cjsRequire(filePath);
        };
        const config = await cosmiconfig("gqty", {
          searchPlaces: ["gqty.config.cjs", "gqty.config.js", "package.json"],
          loaders: {
            ".cjs": cjsLoader,
            ".js": cjsLoader
          }
        }).search();
        if (!config || config.isEmpty) {
          const filepath = (config == null ? void 0 : config.filepath) || defaultFilePath;
          const NODE_ENV = process.env["NODE_ENV"];
          if (NODE_ENV !== "test" && NODE_ENV !== "production" && __innerState.isCLI) {
            const { format } = (await Promise.resolve().then(() => (init_prettier(), prettier_exports))).formatPrettier({
              parser: "typescript"
            });
            const config2 = __spreadValues({}, defaultConfig);
            delete config2.preImport;
            delete config2.enumsAsStrings;
            await promises.writeFile(defaultFilePath, await format(`
                      /**
                       * @type {import("@gqty/cli").GQtyConfig}
                       */
                      const config = ${JSON.stringify(config2)};
                      
                      module.exports = config;`));
          }
          return resolve4({
            filepath,
            config: defaultConfig
          });
        }
        resolve4({
          config: getValidConfig(config.config),
          filepath: config.filepath
        });
      } catch (err) {
        console.error(err);
        resolve4(defaultGQtyConfig);
      }
    });
  }
});

// src/introspection.ts
var introspection_exports = {};
__export(introspection_exports, {
  getRemoteSchema: () => getRemoteSchema
});
var getRemoteSchema;
var init_introspection = __esm({
  "src/introspection.ts"() {
    init_config();
    getRemoteSchema = async (endpoint, { headers } = {}) => {
      const executor = async ({ document, variables }) => {
        var _a;
        headers || (headers = ((_a = (await gqtyConfigPromise).config.introspection) == null ? void 0 : _a.headers) || defaultConfig.introspection.headers);
        const query = print(document);
        const fetchResult = await fetch(endpoint, {
          method: "POST",
          headers: __spreadValues({
            "Content-Type": "application/json"
          }, headers),
          body: JSON.stringify({ query, variables })
        });
        return fetchResult.json();
      };
      const schema = wrapSchema({
        schema: await introspectSchema(executor, {
          endpoint
        }),
        executor
      });
      return schema;
    };
  }
});
async function generate(schema, {
  preImport,
  scalarTypes,
  react,
  endpoint,
  enumsAsStrings,
  subscriptions,
  javascriptOutput
} = {}, { ignoreArgs } = {}) {
  var _a, _b, _c, _d, _e, _f, _g;
  const gqtyConfig = (await gqtyConfigPromise).config;
  const isJavascriptOutput = (_a = javascriptOutput != null ? javascriptOutput : gqtyConfig.javascriptOutput) != null ? _a : defaultConfig.javascriptOutput;
  if (isJavascriptOutput) {
    if (gqtyConfig.enumsAsStrings) {
      console.warn(`"enumsAsStrings" is automatically set as "true" with "javascriptOutput" enabled.`);
    }
    enumsAsStrings = true;
  } else {
    enumsAsStrings != null ? enumsAsStrings : enumsAsStrings = (_b = gqtyConfig.enumsAsStrings) != null ? _b : false;
  }
  scalarTypes || (scalarTypes = gqtyConfig.scalarTypes || defaultConfig.scalarTypes);
  endpoint || (endpoint = (_d = (_c = gqtyConfig.introspection) == null ? void 0 : _c.endpoint) != null ? _d : defaultConfig.introspection.endpoint);
  if (endpoint == null || !(endpoint.startsWith("http://") && endpoint.startsWith("https://"))) {
    endpoint = "/api/graphql";
  }
  react != null ? react : react = (_e = gqtyConfig.react) != null ? _e : defaultConfig.react;
  preImport != null ? preImport : preImport = (_f = gqtyConfig.preImport) != null ? _f : defaultConfig.preImport;
  subscriptions != null ? subscriptions : subscriptions = (_g = gqtyConfig.subscriptions) != null ? _g : defaultConfig.subscriptions;
  const { format } = formatPrettier({
    parser: "typescript"
  });
  schema = lexicographicSortSchema(schema);
  const codegenResultPromise = codegen({
    schema: parse(printSchemaWithDirectives(schema)),
    config: {},
    documents: [],
    filename: "gqty.generated.ts",
    pluginMap: {
      typescript: typescriptPlugin
    },
    plugins: [
      {
        typescript: {
          onlyOperationTypes: true,
          declarationKind: "interface",
          addUnderscoreToArgsType: true,
          scalars: scalarTypes,
          namingConvention: "keep",
          enumsAsTypes: enumsAsStrings
        }
      }
    ]
  });
  const config = schema.toConfig();
  const scalarsEnumsHash = {};
  const enumsNames = [];
  const inputTypeNames = /* @__PURE__ */ new Set();
  const generatedSchema = {
    query: {},
    mutation: {},
    subscription: {}
  };
  const queryType = config.query;
  const mutationType = config.mutation;
  const subscriptionType = config.subscription;
  const descriptions = /* @__PURE__ */ new Map();
  const fieldsDescriptions = /* @__PURE__ */ new Map();
  const fieldsArgsDescriptions = /* @__PURE__ */ new Map();
  function addDescription(typeName) {
    var _a2, _b2, _c2;
    if (Array.isArray(typeName)) {
      const data = typeName[2] ? (_b2 = (_a2 = fieldsArgsDescriptions.get(typeName[0])) == null ? void 0 : _a2[typeName[1]]) == null ? void 0 : _b2[typeName[2]] : (_c2 = fieldsDescriptions.get(typeName[0])) == null ? void 0 : _c2[typeName[1]];
      let comment = "";
      if (data == null ? void 0 : data.description) {
        comment += "\n" + data.description.trim().split("\n").map((line) => "* " + line).join("\n");
      }
      if (data == null ? void 0 : data.deprecated) {
        comment += "\n* @deprecated " + data.deprecated.trim().replace(/\n/g, ". ").trim();
      }
      if (data == null ? void 0 : data.defaultValue) {
        comment += "\n* @defaultValue `" + data.defaultValue.trim() + "`";
      }
      return comment ? `/** ${comment} 
      */
` : "";
    } else {
      const desc = descriptions.get(typeName);
      return desc ? `/**
        ${desc.trim().split("\n").map((line) => "* " + line).join("\n")}
      */
` : "";
    }
  }
  const parseEnumType = (type) => {
    scalarsEnumsHash[type.name] = true;
    enumsNames.push(type.name);
    const values = type.getValues();
    const enumValuesDescriptions = {};
    for (const value of values) {
      if (value.deprecationReason || value.description) {
        enumValuesDescriptions[value.name] = {
          description: value.description,
          deprecated: value.deprecationReason
        };
      }
    }
    fieldsDescriptions.set(type.name, enumValuesDescriptions);
  };
  const parseScalarType = (type) => {
    scalarsEnumsHash[type.name] = true;
  };
  const interfacesOfObjectTypesMap = /* @__PURE__ */ new Map();
  const parseObjectType = (type, typeName = type.name) => {
    const fields = type.getFields();
    const interfaces = type.getInterfaces();
    if (interfaces.length) {
      interfacesOfObjectTypesMap.set(type.name, interfaces.map((v) => v.name));
      for (const interfaceType of interfaces) {
        let objectTypesList = unionsAndInterfacesObjectTypesMap.get(interfaceType.name);
        if (objectTypesList == null) {
          unionsAndInterfacesObjectTypesMap.set(interfaceType.name, objectTypesList = []);
        }
        objectTypesList.push(type.name);
      }
    }
    const schemaType = {
      __typename: { __type: "String!" }
    };
    const objectFieldsDescriptions = {};
    const objectFieldsArgsDescriptions = {};
    Object.entries(fields).forEach(([fieldName, gqlType]) => {
      if (gqlType.description || gqlType.deprecationReason) {
        objectFieldsDescriptions[fieldName] = {
          description: gqlType.description,
          deprecated: gqlType.deprecationReason
        };
      }
      schemaType[fieldName] = {
        __type: gqlType.type.toString()
      };
      if (gqlType.args.length) {
        if (ignoreArgs) {
          const isEveryArgOptional = gqlType.args.every(({ type: type2 }) => {
            return isNullableType(type2);
          });
          if (isEveryArgOptional) {
            const shouldIgnore = ignoreArgs(gqlType);
            if (shouldIgnore)
              return;
          }
        }
        objectFieldsArgsDescriptions[fieldName] || (objectFieldsArgsDescriptions[fieldName] = {});
        schemaType[fieldName].__args = gqlType.args.reduce((acum, arg) => {
          acum[arg.name] = arg.type.toString();
          if (arg.description || arg.deprecationReason || arg.defaultValue != null) {
            objectFieldsArgsDescriptions[fieldName][arg.name] = {
              defaultValue: arg.defaultValue != null ? JSON.stringify(arg.defaultValue) : null,
              deprecated: arg.deprecationReason,
              description: arg.description
            };
          }
          return acum;
        }, {});
      }
    });
    fieldsDescriptions.set(type.name, objectFieldsDescriptions);
    fieldsArgsDescriptions.set(type.name, objectFieldsArgsDescriptions);
    generatedSchema[typeName] = schemaType;
  };
  const unionsAndInterfacesObjectTypesMap = /* @__PURE__ */ new Map();
  const parseUnionType = (type) => {
    const unionTypes = type.getTypes();
    const list = [];
    unionsAndInterfacesObjectTypesMap.set(type.name, list);
    for (const objectType of unionTypes) {
      list.push(objectType.name);
    }
    generatedSchema[type.name] = {
      __typename: { __type: "String!" }
    };
  };
  const parseInputType = (type) => {
    inputTypeNames.add(type.name);
    const fields = type.getFields();
    const schemaType = {};
    const inputFieldDescriptions = {};
    Object.entries(fields).forEach(([key, value]) => {
      schemaType[key] = {
        __type: value.type.toString()
      };
      if (value.description || value.deprecationReason || value.defaultValue) {
        inputFieldDescriptions[key] = {
          description: value.description,
          deprecated: value.deprecationReason,
          defaultValue: value.defaultValue != null ? JSON.stringify(value.defaultValue) : null
        };
      }
    });
    generatedSchema[type.name] = schemaType;
  };
  const parseInterfaceType = (type) => {
    const schemaType = {
      __typename: { __type: "String!" }
    };
    const fields = type.getFields();
    const interfaceFieldDescriptions = {};
    const objectFieldsArgsDescriptions = {};
    Object.entries(fields).forEach(([fieldName, gqlType]) => {
      ({
        fieldName,
        __type: gqlType.type.toString()
      });
      schemaType[fieldName] = {
        __type: gqlType.type.toString()
      };
      let hasArgs = true;
      if (gqlType.args.length) {
        if (ignoreArgs) {
          const isEveryArgOptional = gqlType.args.every(({ type: type2 }) => {
            return isNullableType(type2);
          });
          if (isEveryArgOptional) {
            const shouldIgnore = ignoreArgs(gqlType);
            if (shouldIgnore) {
              hasArgs = false;
            }
          }
        }
      } else {
        hasArgs = false;
      }
      if (hasArgs) {
        objectFieldsArgsDescriptions[fieldName] || (objectFieldsArgsDescriptions[fieldName] = {});
        schemaType[fieldName].__args = gqlType.args.reduce((acum, arg) => {
          acum[arg.name] = arg.type.toString();
          if (arg.description || arg.deprecationReason || arg.defaultValue != null) {
            objectFieldsArgsDescriptions[fieldName][arg.name] = {
              defaultValue: arg.defaultValue != null ? JSON.stringify(arg.defaultValue) : null,
              deprecated: arg.deprecationReason,
              description: arg.description
            };
          }
          return acum;
        }, {});
      }
      if (gqlType.description || gqlType.deprecationReason) {
        interfaceFieldDescriptions[fieldName] = {
          description: gqlType.description,
          deprecated: gqlType.deprecationReason
        };
      }
    });
    fieldsDescriptions.set(type.name, interfaceFieldDescriptions);
    fieldsArgsDescriptions.set(type.name, objectFieldsArgsDescriptions);
    generatedSchema[type.name] = schemaType;
  };
  config.types.forEach((type) => {
    if (type.description) {
      descriptions.set(type.name, type.description);
    }
    if (type.name.startsWith("__") || type === queryType || type === mutationType || type === subscriptionType) {
      return;
    }
    if (isScalarType(type)) {
      parseScalarType(type);
    } else if (isObjectType(type)) {
      parseObjectType(type);
    } else if (isInterfaceType(type)) {
      parseInterfaceType(type);
    } else if (isUnionType(type)) {
      parseUnionType(type);
    } else if (isEnumType(type)) {
      parseEnumType(type);
    } else if (isInputObjectType(type)) {
      parseInputType(type);
    }
  });
  if (queryType) {
    parseObjectType(queryType, "query");
  }
  if (mutationType) {
    parseObjectType(mutationType, "mutation");
  }
  if (subscriptionType) {
    parseObjectType(subscriptionType, "subscription");
  }
  const unionsMapObj = Array.from(unionsAndInterfacesObjectTypesMap.entries()).reduce((acum, [key, value]) => {
    generatedSchema[key]["$on"] = {
      __type: `$${key}!`
    };
    acum[key] = value;
    return acum;
  }, {});
  if (unionsAndInterfacesObjectTypesMap.size) {
    generatedSchema[SchemaUnionsKey] = unionsMapObj;
  }
  function parseArgType({
    pureType,
    isArray,
    nullableItems,
    isNullable
  }) {
    let typeToReturn = [
      scalarsEnumsHash[pureType] ? enumsNames.includes(pureType) ? pureType : `Scalars["${pureType}"]` : pureType
    ];
    if (isArray) {
      typeToReturn = [
        "Array<",
        ...nullableItems ? ["Maybe<", ...typeToReturn, ">"] : typeToReturn,
        ">"
      ];
    }
    if (isNullable) {
      typeToReturn = ["Maybe<", ...typeToReturn, ">"];
    }
    return typeToReturn.join("");
  }
  function parseFinalType({
    pureType,
    isArray,
    nullableItems,
    isNullable
  }) {
    let typeToReturn = [
      scalarsEnumsHash[pureType] ? `ScalarsEnums["${pureType}"]` : pureType
    ];
    if (isArray) {
      typeToReturn = [
        "Array<",
        ...nullableItems ? ["Maybe<", ...typeToReturn, ">"] : typeToReturn,
        ">"
      ];
    }
    if (isNullable) {
      typeToReturn = ["Maybe<", ...typeToReturn, ">"];
    }
    return typeToReturn.join("");
  }
  const objectTypeTSTypes = /* @__PURE__ */ new Map();
  let typescriptTypes = sortBy(Object.entries(generatedSchema), (v) => v[0]).reduce((acum, [typeKey, typeValue]) => {
    const typeName = (() => {
      switch (typeKey) {
        case "query": {
          return "Query";
        }
        case "mutation": {
          return "Mutation";
        }
        case "subscription": {
          return "Subscription";
        }
        default: {
          return typeKey;
        }
      }
    })();
    if (inputTypeNames.has(typeName))
      return acum;
    const objectTypeMap = /* @__PURE__ */ new Map();
    if (!unionsAndInterfacesObjectTypesMap.has(typeName)) {
      objectTypeTSTypes.set(typeName, objectTypeMap);
    }
    const interfaceOrUnionsObjectTypes = unionsAndInterfacesObjectTypesMap.get(typeName);
    acum += `

      ${addDescription(typeName)}export interface ${typeName} { 
        __typename?: ${interfaceOrUnionsObjectTypes ? interfaceOrUnionsObjectTypes.map((v) => `"${v}"`).join(" | ") : `"${typeName}"`}; ${Object.entries(typeValue).reduce((acum2, [fieldKey, fieldValue]) => {
      if (fieldKey === "__typename") {
        objectTypeMap.set(fieldKey, `?: "${typeName}"`);
        return acum2;
      }
      const fieldValueProps = parseSchemaType(fieldValue.__type);
      const typeToReturn = parseFinalType(fieldValueProps);
      let finalType;
      if (fieldValue.__args) {
        const argsEntries = Object.entries(fieldValue.__args);
        let onlyNullableArgs = true;
        const argTypes = argsEntries.reduce((acum3, [argKey, argValue]) => {
          const argValueProps = parseSchemaType(argValue);
          const connector = argValueProps.isNullable ? "?:" : ":";
          if (!argValueProps.isNullable) {
            onlyNullableArgs = false;
          }
          const argTypeValue = parseArgType(argValueProps);
          acum3 += `${addDescription([
            typeName,
            fieldKey,
            argKey
          ])}${argKey}${connector} ${argTypeValue};
`;
          return acum3;
        }, "");
        const argsConnector = onlyNullableArgs ? "?:" : ":";
        finalType = `: (args${argsConnector} {${argTypes}}) => ${typeToReturn}`;
      } else {
        const connector = fieldValueProps.isNullable ? "?:" : ":";
        finalType = `${connector} ${typeToReturn}`;
      }
      objectTypeMap.set(fieldKey, finalType);
      acum2 += "\n" + addDescription([typeName, fieldKey]) + fieldKey + finalType;
      return acum2;
    }, "")}
      }
      `;
    return acum;
  }, "");
  const objectTypesEntries = sortBy(Array.from(objectTypeTSTypes.entries()), (v) => v[0]);
  typescriptTypes += `
  export interface SchemaObjectTypes {
    ${objectTypesEntries.reduce((acum, [typeName]) => {
    acum += `${typeName}:${typeName};`;
    return acum;
  }, "")}
  }
  export type SchemaObjectTypesNames = ${objectTypesEntries.map(([key]) => `"${key}"`).join(" | ")};
  `;
  if (unionsAndInterfacesObjectTypesMap.size) {
    typescriptTypes += `
    ${sortBy(Array.from(unionsAndInterfacesObjectTypesMap.entries()), (v) => v[0]).reduce((acum, [unionInterfaceName, objectTypes]) => {
      acum += `
      export interface $${unionInterfaceName} {
        ${objectTypes.map((typeName) => `${typeName}?:${typeName}`).join("\n")}
      }
      `;
      return acum;
    }, "")}
    `;
  }
  typescriptTypes += `
    export interface GeneratedSchema {
      query: Query
      mutation: Mutation
      subscription: Subscription
    }
    `;
  typescriptTypes += `
    export type MakeNullable<T> = {
      [K in keyof T]: T[K] | undefined;
    };
  
    export interface ScalarsEnums extends MakeNullable<Scalars> {
      ${sortBy(enumsNames).reduce((acum, enumName) => {
    acum += `${enumName}: ${enumName} | undefined;`;
    return acum;
  }, "")}
    }
    `;
  function typeDoc(type) {
    return `/**
 * @type {${type}}
 */
`;
  }
  const queryFetcher = `
    ${isJavascriptOutput ? typeDoc('import("gqty").QueryFetcher') + "const queryFetcher" : "const queryFetcher : QueryFetcher"} = async function (query, variables) {
        // Modify "${endpoint}" if needed
        const response = await fetch("${endpoint}", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            query,
            variables,
          }),
          mode: "cors",
        });
            
        const json = await response.json();
      
        return json;
      };
    `;
  const hasUnions = !!unionsAndInterfacesObjectTypesMap.size;
  const scalarsEnumsHashString = JSON.stringify(Object.keys(scalarsEnumsHash).sort().reduce((acum, key) => {
    acum[key] = true;
    return acum;
  }, {}));
  const generatedSchemaCodeString = sortBy(Object.entries(generatedSchema), (v) => v[0]).reduceRight((acum, [key, value]) => {
    return `${JSON.stringify(key)}:${JSON.stringify(value)}, ${acum}`;
  }, hasUnions ? `[SchemaUnionsKey]: ${JSON.stringify(unionsMapObj)}` : "");
  const javascriptSchemaCode = await format(`
/**
 * GQTY AUTO-GENERATED CODE: PLEASE DO NOT MODIFY MANUALLY
 */
${hasUnions ? 'import { SchemaUnionsKey } from "gqty";' : ""}

${typeDoc('import("gqty").ScalarsEnumsHash')}export const scalarsEnumsHash = ${scalarsEnumsHashString};

export const generatedSchema = {${generatedSchemaCodeString}};
  `);
  const schemaCode = await format(`
/**
 * GQTY AUTO-GENERATED CODE: PLEASE DO NOT MODIFY MANUALLY
 */
  ${preImport}

  ${hasUnions ? 'import { SchemaUnionsKey } from "gqty";' : ""}

  ${await codegenResultPromise}

  export${isJavascriptOutput ? " declare" : ""} const scalarsEnumsHash: import("gqty").ScalarsEnumsHash${isJavascriptOutput ? ";" : ` = ${scalarsEnumsHashString};`}
  export${isJavascriptOutput ? " declare" : ""} const generatedSchema ${isJavascriptOutput ? ":" : "="} {${generatedSchemaCodeString}}${isJavascriptOutput ? "" : " as const"};

  ${typescriptTypes}
    `);
  let reactClientCode = "";
  if (react) {
    if (isJavascriptOutput) {
      reactClientCode = `
      ${typeDoc('import("@gqty/react").ReactClient<import("./schema.generated").GeneratedSchema>')}const reactClient = createReactClient(client, {
        defaults: {
          // Set this flag as "true" if your usage involves React Suspense
          // Keep in mind that you can overwrite it in a per-hook basis
          suspense: false,
    
          // Set this flag based on your needs
          staleWhileRevalidate: false
        }
      });

      const {
        graphql,
        useQuery,
        usePaginatedQuery,
        useTransactionQuery,
        useLazyQuery,
        useRefetch,
        useMutation,
        useMetaState,
        prepareReactRender,
        useHydrateCache,
        prepareQuery,
        ${subscriptions ? "useSubscription," : ""}
      } = reactClient;

      export { 
        graphql,
        useQuery,
        usePaginatedQuery,
        useTransactionQuery,
        useLazyQuery,
        useRefetch,
        useMutation,
        useMetaState,
        prepareReactRender,
        useHydrateCache,
        prepareQuery,
        ${subscriptions ? "useSubscription," : ""}
       }
      `.trim();
    } else {
      reactClientCode = `
      const {
        graphql,
        useQuery,
        usePaginatedQuery,
        useTransactionQuery,
        useLazyQuery,
        useRefetch,
        useMutation,
        useMetaState,
        prepareReactRender,
        useHydrateCache,
        prepareQuery,
        ${subscriptions ? "useSubscription," : ""}
      } = createReactClient<GeneratedSchema>(client, {
        defaults: {
          // Set this flag as "true" if your usage involves React Suspense
          // Keep in mind that you can overwrite it in a per-hook basis
          suspense: false,
    
          // Set this flag based on your needs
          staleWhileRevalidate: false
        }
      });
      
      export { 
        graphql,
        useQuery,
        usePaginatedQuery,
        useTransactionQuery,
        useLazyQuery,
        useRefetch,
        useMutation,
        useMetaState,
        prepareReactRender,
        useHydrateCache,
        prepareQuery,
        ${subscriptions ? "useSubscription," : ""}
       }
      `;
    }
  }
  const clientCode = await format(`
/**
 * GQTY: You can safely modify this file and Query Fetcher based on your needs
 */

  ${react ? `import { createReactClient } from "@gqty/react"` : ""}
  ${subscriptions ? `import { createSubscriptionsClient } from "@gqty/subscriptions"` : ""}
  ${isJavascriptOutput ? "" : 'import type { QueryFetcher } from "gqty";'}
  import { createClient } from "gqty";
  ${isJavascriptOutput ? "" : 'import type { GeneratedSchema, SchemaObjectTypes, SchemaObjectTypesNames } from "./schema.generated";'}
  import { generatedSchema, scalarsEnumsHash } from "./schema.generated";


  ${queryFetcher}

  ${subscriptions ? `
  const subscriptionsClient = 
  typeof window !== "undefined" ?
  createSubscriptionsClient({
    wsEndpoint: () => {
      // Modify if needed
      const url = new URL("${endpoint}", window.location.href);
      url.protocol = url.protocol.replace('http', 'ws');
      return url.href;
    }
  }) : undefined;
  ` : ""}

  ${isJavascriptOutput ? `${typeDoc('import("gqty").GQtyClient<import("./schema.generated").GeneratedSchema>')}export const client = createClient({
        schema: generatedSchema,
        scalarsEnumsHash, 
        queryFetcher
        ${subscriptions ? ", subscriptionsClient" : ""}
      });` : `export const client = createClient<GeneratedSchema, SchemaObjectTypesNames, SchemaObjectTypes>({ 
    schema: generatedSchema, 
    scalarsEnumsHash, 
    queryFetcher
    ${subscriptions ? ", subscriptionsClient" : ""}
  });`}
  

  const { query, mutation, mutate, subscription, resolved, refetch, track } = client;

  export { query, mutation, mutate, subscription, resolved, refetch, track };

  ${reactClientCode}

  export * from "./schema.generated";
  `);
  return {
    clientCode,
    schemaCode,
    javascriptSchemaCode,
    generatedSchema,
    scalarsEnumsHash,
    isJavascriptOutput
  };
}
var init_generate = __esm({
  "src/generate.ts"() {
    init_config();
    init_prettier();
  }
});

// src/writeGenerate.ts
var writeGenerate_exports = {};
__export(writeGenerate_exports, {
  writeGenerate: () => writeGenerate
});
async function writeClientCode({
  destinationPath,
  clientCode,
  onExistingFileConflict
}) {
  if (existsSync(destinationPath)) {
    if (onExistingFileConflict) {
      const existingFile = await promises.readFile(destinationPath, {
        encoding: "utf-8"
      });
      onExistingFileConflict(existingFile);
    }
    return;
  }
  await promises.writeFile(destinationPath, clientCode, {
    encoding: "utf-8"
  });
}
function waitFunctions(...fns) {
  return Promise.all(fns.map((fn) => fn()));
}
async function writeSchemaCode({
  schemaCode,
  destinationPath,
  isJavascriptOutput,
  javascriptSchemaCode
}) {
  await waitFunctions(async () => {
    const schemaPath = resolve(dirname(destinationPath), isJavascriptOutput ? "./schema.generated.d.ts" : "./schema.generated.ts");
    if (existsSync(schemaPath)) {
      const existingCode = await promises.readFile(schemaPath, {
        encoding: "utf-8"
      });
      if (existingCode === schemaCode)
        return;
    }
    await promises.writeFile(schemaPath, schemaCode, {
      encoding: "utf-8"
    });
  }, async () => {
    if (isJavascriptOutput) {
      const schemaPath = resolve(dirname(destinationPath), "./schema.generated.js");
      if (existsSync(schemaPath)) {
        const existingCode = await promises.readFile(schemaPath, {
          encoding: "utf-8"
        });
        if (existingCode === javascriptSchemaCode)
          return;
      }
      await promises.writeFile(schemaPath, javascriptSchemaCode, {
        encoding: "utf-8"
      });
    }
  });
}
async function writeGenerate(schema, destinationPath, generateOptions = {}, onExistingFileConflict, transformsGenerate) {
  var _a, _b;
  const isJavascriptOutput = (_b = (_a = generateOptions.javascriptOutput) != null ? _a : (await gqtyConfigPromise).config.javascriptOutput) != null ? _b : defaultConfig.javascriptOutput;
  if (isJavascriptOutput) {
    if (!destinationPath.endsWith(".js")) {
      const err = Error('You have to specify the ".js" extension, instead, it received: "' + destinationPath + '"');
      Error.captureStackTrace(err, writeGenerate);
      throw err;
    }
  } else if (!destinationPath.endsWith(".ts")) {
    const err = Error('You have to specify the ".ts" extension, instead, it received: "' + destinationPath + '"');
    Error.captureStackTrace(err, writeGenerate);
    throw err;
  }
  destinationPath = resolve(destinationPath);
  const [{ clientCode, schemaCode, javascriptSchemaCode }] = await Promise.all([
    generate(schema, generateOptions, transformsGenerate),
    mkdirp(dirname(destinationPath))
  ]);
  await Promise.all([
    writeClientCode({ clientCode, destinationPath, onExistingFileConflict }),
    writeSchemaCode({
      schemaCode,
      destinationPath,
      isJavascriptOutput,
      javascriptSchemaCode
    })
  ]);
  return destinationPath;
}
var init_writeGenerate = __esm({
  "src/writeGenerate.ts"() {
    init_config();
    init_generate();
  }
});

// src/bin.ts
init_config();
init_innerState();

// src/inspectWriteGenerate.ts
init_config();
async function inspectWriteGenerate({
  endpoint,
  destination,
  generateOptions,
  cli,
  headers,
  transformSchemaOptions
} = {}) {
  if (destination) {
    defaultConfig.destination = destination;
  }
  if (endpoint) {
    defaultConfig.introspection.endpoint = endpoint;
  } else if (existsSync(resolve("./schema.gql"))) {
    endpoint = "./schema.gql";
    defaultConfig.introspection.endpoint = endpoint;
  } else {
    const { config, filepath } = await gqtyConfigPromise;
    const configIntrospectionEndpoint = config.introspection && config.introspection.endpoint;
    if (configIntrospectionEndpoint && configIntrospectionEndpoint !== DUMMY_ENDPOINT) {
      endpoint = configIntrospectionEndpoint;
    } else {
      console.error(`
Please modify "${filepath.endsWith("package.json") ? "gqty" : "config"}.introspection.endpoint" in: "${filepath}".`);
      throw Error("ERROR: No introspection endpoint specified in configuration file.");
    }
  }
  if (!destination) {
    const configDestination = (await gqtyConfigPromise).config.destination;
    destination = configDestination || defaultConfig.destination;
  }
  destination = resolve(destination);
  const genOptions = Object.assign({}, generateOptions);
  let schema;
  defaultConfig.introspection.endpoint = endpoint;
  defaultConfig.introspection.headers = headers || {};
  if (endpoint.startsWith("http://") || endpoint.startsWith("https://")) {
    schema = await (await Promise.resolve().then(() => (init_introspection(), introspection_exports))).getRemoteSchema(endpoint, {
      headers
    });
  } else {
    defaultConfig.introspection.endpoint = DUMMY_ENDPOINT;
    if (existsSync(endpoint)) {
      const file = await promises.readFile(endpoint, {
        encoding: "utf-8"
      });
      if (endpoint.endsWith(".json")) {
        const parsedFile = JSON.parse(file);
        let dataField;
        if (typeof parsedFile === "object") {
          if ("data" in parsedFile && parsedFile.data) {
            dataField = parsedFile.data;
          } else if ("__schema" in parsedFile) {
            dataField = parsedFile;
          }
        }
        if (!(typeof dataField === "object"))
          throw Error('Invalid JSON introspection result, expected "__schema" or "data.__schema" field.');
        schema = buildClientSchema(dataField);
      } else {
        schema = buildSchema(file);
      }
    } else {
      throw Error(`File "${endpoint}" doesn't exists. If you meant to inspect a GraphQL API, make sure to put http:// or https:// in front of it.`);
    }
  }
  const generatedPath = await (await Promise.resolve().then(() => (init_writeGenerate(), writeGenerate_exports))).writeGenerate(schema, destination, genOptions, async (existingFile) => {
    var _a, _b;
    const subscriptions = (_a = genOptions.subscriptions) != null ? _a : (await gqtyConfigPromise).config.subscriptions;
    const react = (_b = genOptions.react) != null ? _b : (await gqtyConfigPromise).config.react;
    const advice = `
If you meant to change this, please remove "${destination}" and re-run code generation.`;
    if (subscriptions) {
      if (!existingFile.includes("createSubscriptionsClient")) {
        console.warn(`[Warning] You've changed the option "subscriptions" to 'true', which is different from your existing "${destination}".` + advice);
      }
    }
    if (react) {
      if (!existingFile.includes("createReactClient")) {
        console.warn(`[Warning] You've changed the option "react" to 'true', which is different from your existing "${destination}".` + advice);
      }
    }
    if (existingFile.includes("export const {")) {
      console.warn(`[Warning] To prevent possible bundling issues, it's recommended to change the export syntax from "export const { query, ... } = client;" to "const { query, ... } = client; export { query, ... };"`);
    }
  }, transformSchemaOptions);
  if (cli) {
    console.log("Code generated successfully at " + generatedPath);
  }
}

// src/bin.ts
__innerState.isCLI = true;
program.version("2.3.1").description("CLI for gqty");
program.command("generate [endpoint] [destination]").option("--react", "Create React client").description(`Inspect or read from a file a GraphQL Schema and generate the gqty client in the specified directory (./src/generated/graphql.ts by default).
EXAMPLE 1: "gqty generate ./schema.gql --react" 
EXAMPLE 2: "gqty generate http://localhost:3000/graphql src/gqty/index.ts"
EXAMPLE 3 (Configuration file): "gqty generate"`).action(async (endpoint, destination, opts) => {
  let react;
  if (opts.react != null) {
    react = defaultConfig.react = typeof opts.react === "boolean" ? opts.react : !!opts.react;
  }
  await inspectWriteGenerate({
    endpoint,
    destination,
    cli: true,
    generateOptions: {
      react
    }
  }).catch((err) => {
    if (err instanceof Error)
      delete err.stack;
    console.error(err);
    process.exit(1);
  });
  process.exit(0);
});
program.parse(process.argv);
