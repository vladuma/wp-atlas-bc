import { cosmiconfig } from 'cosmiconfig';
import { promises } from 'fs';
import { createRequire } from 'module';
import { resolve } from 'path';
import { __innerState } from './innerState.mjs';

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
const cjsRequire = globalThis.require || createRequire(import.meta.url);
function isPlainObject(v) {
  return v != null && typeof v === "object" && !Array.isArray(v);
}
function isStringRecord(v) {
  return isPlainObject(v) && Object.values(v).every((v2) => typeof v2 === "string");
}
const DUMMY_ENDPOINT = "SPECIFY_ENDPOINT_OR_SCHEMA_FILE_PATH_HERE";
const defaultConfig = {
  react: (() => {
    try {
      cjsRequire.resolve("react");
      return true;
    } catch (err) {
    }
    return false;
  })(),
  scalarTypes: {
    DateTime: "string"
  },
  introspection: {
    endpoint: DUMMY_ENDPOINT,
    headers: {}
  },
  destination: "./src/gqty/index.ts",
  subscriptions: false,
  javascriptOutput: false,
  enumsAsStrings: false,
  preImport: ""
};
function warnConfig(fieldName, invalidValue, expectedValue, defaultValue) {
  console.warn(`Warning, invalid config ${fieldName}, got: ${JSON.stringify(invalidValue)}, expected ${expectedValue}. ${JSON.stringify(defaultValue)} used instead.`);
}
function getValidConfig(v) {
  if (isPlainObject(v)) {
    const newConfig = {};
    if (typeof v.javascriptOutput === "boolean") {
      newConfig.javascriptOutput = v.javascriptOutput;
    }
    for (const [key, value] of Object.entries(v)) {
      if (value === void 0)
        continue;
      switch (key) {
        case "destination":
        case "preImport": {
          if (typeof value === "string") {
            newConfig[key] = value;
          } else {
            warnConfig(key, value, "string", defaultConfig[key]);
          }
          break;
        }
        case "javascriptOutput":
        case "react":
        case "subscriptions":
        case "enumsAsStrings": {
          if (typeof value === "boolean") {
            newConfig[key] = value;
          } else {
            warnConfig(key, value, "boolean", defaultConfig[key]);
          }
          break;
        }
        case "scalarTypes": {
          if (isStringRecord(value)) {
            newConfig[key] = value;
          } else {
            warnConfig(key, value, '"object of strings"', defaultConfig[key]);
          }
          break;
        }
        case "introspection": {
          if (isPlainObject(value)) {
            const introspectionOptions = {};
            for (const [introspectionKey, introspectionValue] of Object.entries(value)) {
              if (introspectionValue === void 0)
                continue;
              switch (introspectionKey) {
                case "endpoint": {
                  if (typeof introspectionValue === "string") {
                    introspectionOptions[introspectionKey] = introspectionValue;
                  } else {
                    warnConfig(`${key}.${introspectionKey}`, introspectionValue, "string", defaultConfig.introspection.endpoint);
                  }
                  break;
                }
                case "headers": {
                  if (isStringRecord(introspectionValue)) {
                    introspectionOptions[introspectionKey] = introspectionValue;
                  } else {
                    warnConfig(`${key}.${introspectionKey}`, introspectionValue, '"object of strings"', defaultConfig.introspection.headers);
                  }
                  break;
                }
                default: {
                  console.warn(`Warning, invalid and unused config property "${key}.${introspectionKey}": ${JSON.stringify(value)}`);
                }
              }
            }
            newConfig[key] = introspectionOptions;
          } else {
            warnConfig(key, value, "object", defaultConfig[key]);
          }
          break;
        }
        default:
          console.warn(`Warning, invalid and unused config property "${key}": ${JSON.stringify(value)}`);
      }
    }
    return newConfig;
  } else {
    console.warn("Invalid config, using instead: " + JSON.stringify(defaultConfig, null, 2));
    return defaultConfig;
  }
}
const defaultFilePath = resolve(process.cwd(), "gqty.config.cjs");
const defaultGQtyConfig = {
  filepath: defaultFilePath,
  config: defaultConfig
};
const gqtyConfigPromise = new Promise(async (resolve2) => {
  try {
    const cjsLoader = (filePath) => {
      return cjsRequire(filePath);
    };
    const config = await cosmiconfig("gqty", {
      searchPlaces: ["gqty.config.cjs", "gqty.config.js", "package.json"],
      loaders: {
        ".cjs": cjsLoader,
        ".js": cjsLoader
      }
    }).search();
    if (!config || config.isEmpty) {
      const filepath = (config == null ? void 0 : config.filepath) || defaultFilePath;
      const NODE_ENV = process.env["NODE_ENV"];
      if (NODE_ENV !== "test" && NODE_ENV !== "production" && __innerState.isCLI) {
        const { format } = (await import('./prettier.mjs')).formatPrettier({
          parser: "typescript"
        });
        const config2 = __spreadValues({}, defaultConfig);
        delete config2.preImport;
        delete config2.enumsAsStrings;
        await promises.writeFile(defaultFilePath, await format(`
                      /**
                       * @type {import("@gqty/cli").GQtyConfig}
                       */
                      const config = ${JSON.stringify(config2)};
                      
                      module.exports = config;`));
      }
      return resolve2({
        filepath,
        config: defaultConfig
      });
    }
    resolve2({
      config: getValidConfig(config.config),
      filepath: config.filepath
    });
  } catch (err) {
    console.error(err);
    resolve2(defaultGQtyConfig);
  }
});

export { DUMMY_ENDPOINT, defaultConfig, getValidConfig, gqtyConfigPromise };
