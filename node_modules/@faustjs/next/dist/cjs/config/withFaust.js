"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.withFaust = exports.createRedirects = void 0;
const lodash_1 = require("lodash");
const isFunction_js_1 = __importDefault(require("lodash/isFunction.js"));
async function createRedirects(redirectFn, previewDestination = '/preview') {
    let redirects = [];
    if ((0, isFunction_js_1.default)(redirectFn)) {
        redirects = await redirectFn();
    }
    redirects.unshift({
        source: `/((?!${(0, lodash_1.trim)(previewDestination, '/')}$).*)`,
        has: [
            {
                type: 'query',
                key: 'preview',
                value: 'true',
            },
        ],
        destination: `/${(0, lodash_1.trim)(previewDestination, '/')}`,
        permanent: false,
    });
    return redirects;
}
exports.createRedirects = createRedirects;
/**
 * A helper function to merge Faust.js related Next.js config with a user defined Next.js config.
 *
 * @param {NextConfig} config
 * @param {withFaustConfig} withFaustConfig
 * @returns {NextConfig}
 */
function withFaust(config, withFaustConfig) {
    const { previewDestination } = withFaustConfig || {};
    const nextConfig = config !== null && config !== void 0 ? config : {};
    const existingRedirects = nextConfig.redirects;
    nextConfig.redirects = () => createRedirects(existingRedirects, previewDestination);
    return nextConfig;
}
exports.withFaust = withFaust;
