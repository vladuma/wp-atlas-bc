import * as errors from '../errors';
import type { Result } from '../interfaces/Result';
import type { ResultResponse } from '../interfaces/ResultResponse';
declare const makeSuccess: <F extends Error, S>(value: S) => Result<F, S>;
declare const makeFail: <F extends Error, S>(value: F) => Result<F, S>;
/**
 * Converts a Result instance into its JSON representation.
 * Not all information is preserved from the Result instance.
 * Most notably, non-enumerable properties are skipped.
 */
declare const toJson: <F extends Error, S>(result: Result<F, S>) => {
    type: string;
    subtype: string;
    value?: any;
};
/**
 * Converts JSON to a Result instance.
 * If the JSON represents a fail, converts the error into an instance of SpreeSDKError its subtype.
 */
declare const fromJson: (json: {
    [key: string]: any;
}) => Result<errors.SpreeSDKError, any>;
/**
 * If Spree returns a success response, extracts and returns its data.
 * Otherwise, throws the response's SpreeSDKError. Useful for handling
 * SpreeSDKErrors inside try..catch blocks.
 */
declare const extractSuccess: <ResponseType_1, T extends ResponseType_1>(spreeRequest: Promise<ResultResponse<T>>) => Promise<T>;
export { makeSuccess, makeFail, toJson, fromJson, extractSuccess };
