import type { GQtyError } from '../Error';
import type { InterceptorManager } from '../Interceptor';
import { Selection } from '../Selection';
import { DeferredPromise } from '../Utils';
export declare type SchedulerPromiseValue = {
    error?: GQtyError;
    data?: unknown;
    selections: Set<Selection>;
};
export declare type ResolvingLazyPromise = DeferredPromise<SchedulerPromiseValue>;
export declare type ResolvedLazyPromise = Promise<SchedulerPromiseValue>;
export declare type ErrorSubscriptionEvent = {
    type: 'new_error';
    newError: GQtyError;
    selections: Selection[];
    isLastTry: boolean;
} | {
    type: 'errors_clean';
    selectionsCleaned: Selection[];
} | {
    type: 'retry';
    retryPromise: Promise<SchedulerPromiseValue>;
    selections: Set<Selection>;
};
export declare type ErrorSubscriptionFn = (event: ErrorSubscriptionEvent) => void;
export declare type IsFetchingSubscriptionFn = (isFetching: boolean) => void;
export interface Scheduler {
    resolving: DeferredPromise<SchedulerPromiseValue> | null;
    subscribeResolve: (fn: (promise: Promise<SchedulerPromiseValue>, selection: Selection) => void) => () => void;
    errors: {
        map: Map<Selection, GQtyError>;
        subscribeErrors: (fn: ErrorSubscriptionFn) => () => void;
        triggerError: (newError: GQtyError, selections: Selection[], isLastTry: boolean) => void;
        removeErrors: (selectionsCleaned: Selection[]) => void;
        retryPromise: (retryPromise: Promise<SchedulerPromiseValue>, selections: Set<Selection>) => void;
    };
    isFetching: boolean;
    pendingSelectionsGroups: Set<Set<Selection>>;
    pendingSelectionsGroupsPromises: Map<Set<Selection>, Promise<SchedulerPromiseValue>>;
    getResolvingPromise(selections: Selection | Set<Selection>): ResolvedLazyPromise | void;
}
export declare const createScheduler: ({ globalInterceptor }: InterceptorManager, resolveSchedulerSelections: (selections: Set<Selection>) => Promise<void>, catchSelectionsTimeMS: number) => Scheduler;
