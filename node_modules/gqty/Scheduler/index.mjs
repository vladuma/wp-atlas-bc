import { Selection } from '../Selection/selection.mjs';
import { debounce } from '../Utils/debounce.mjs';
import 'lodash/mergeWith.js';
import { createDeferredPromise } from '../Utils/promise.mjs';

const createScheduler = ({ globalInterceptor }, resolveSchedulerSelections, catchSelectionsTimeMS) => {
  const resolveListeners = new Set();
  function subscribeResolve(fn) {
    resolveListeners.add(fn);
    return function unsubscribe() {
      resolveListeners.delete(fn);
    };
  }
  const errorsMap = new Map();
  const pendingSelectionsGroups = new Set();
  const pendingSelectionsGroupsPromises = new Map();
  const selectionsOnTheFly = new Set();
  const selectionsWithFinalErrors = new Set();
  const scheduler = {
    resolving: null,
    subscribeResolve,
    errors: {
      map: errorsMap,
      subscribeErrors,
      triggerError,
      removeErrors,
      retryPromise
    },
    isFetching: false,
    pendingSelectionsGroups,
    pendingSelectionsGroupsPromises,
    getResolvingPromise
  };
  const errorsListeners = new Set();
  function subscribeErrors(fn) {
    errorsListeners.add(fn);
    return function unsubscribe() {
      errorsListeners.delete(fn);
    };
  }
  function retryPromise(retryPromise2, selections) {
    pendingSelectionsGroups.add(selections);
    pendingSelectionsGroupsPromises.set(selections, retryPromise2);
    retryPromise2.finally(() => {
      pendingSelectionsGroups.delete(selections);
      pendingSelectionsGroupsPromises.delete(selections);
    });
    const data = {
      type: "retry",
      retryPromise: retryPromise2,
      selections
    };
    errorsListeners.forEach((listener) => {
      listener(data);
    });
  }
  function triggerError(newError, selections, isLastTry) {
    if (!selections.length)
      return;
    for (const selection of selections)
      errorsMap.set(selection, newError);
    const data = {
      type: "new_error",
      newError,
      selections,
      isLastTry
    };
    errorsListeners.forEach((listener) => {
      listener(data);
    });
  }
  function removeErrors(selectionsCleaned) {
    if (errorsMap.size === 0)
      return;
    for (const selection of selectionsCleaned) {
      errorsMap.delete(selection);
      selectionsWithFinalErrors.delete(selection);
    }
    const data = {
      type: "errors_clean",
      selectionsCleaned
    };
    errorsListeners.forEach((listener) => {
      listener(data);
    });
  }
  let resolvingPromise = null;
  function getResolvingPromise(selections) {
    if (selections instanceof Selection) {
      for (const [group, promise] of pendingSelectionsGroupsPromises) {
        if (group.has(selections))
          return promise;
      }
    } else {
      for (const selection of selections) {
        for (const [group, promise] of pendingSelectionsGroupsPromises) {
          if (group.has(selection))
            return promise;
        }
      }
    }
  }
  const fetchSelections = debounce((lazyPromise) => {
    resolvingPromise = null;
    const selectionsToFetch = new Set(globalInterceptor.fetchSelections);
    selectionsOnTheFly.clear();
    pendingSelectionsGroups.delete(selectionsOnTheFly);
    pendingSelectionsGroupsPromises.delete(selectionsOnTheFly);
    pendingSelectionsGroups.add(selectionsToFetch);
    pendingSelectionsGroupsPromises.set(selectionsToFetch, lazyPromise.promise);
    resolveSchedulerSelections(selectionsToFetch).then(() => {
      pendingSelectionsGroups.delete(selectionsToFetch);
      pendingSelectionsGroupsPromises.delete(selectionsToFetch);
      if (scheduler.resolving === lazyPromise)
        scheduler.resolving = null;
      lazyPromise.resolve({
        selections: selectionsToFetch
      });
    }, (error) => {
      pendingSelectionsGroups.delete(selectionsToFetch);
      pendingSelectionsGroupsPromises.delete(selectionsToFetch);
      if (scheduler.resolving === lazyPromise)
        scheduler.resolving = null;
      lazyPromise.resolve({
        error,
        selections: selectionsToFetch
      });
    });
  }, catchSelectionsTimeMS);
  function addSelectionToScheduler(selection, notifyResolve = true) {
    if (selection.type === 2)
      notifyResolve = false;
    const existingPromise = getResolvingPromise(selection);
    if (existingPromise) {
      if (!notifyResolve)
        return;
      for (const sub of resolveListeners) {
        sub(existingPromise, selection);
      }
    }
    let lazyPromise;
    if (resolvingPromise === null) {
      lazyPromise = createDeferredPromise();
      lazyPromise.promise.then(({ error }) => {
        if (error)
          console.error(error);
      });
      resolvingPromise = lazyPromise;
      scheduler.resolving = lazyPromise;
    } else {
      lazyPromise = resolvingPromise;
    }
    pendingSelectionsGroups.add(selectionsOnTheFly);
    selectionsOnTheFly.add(selection);
    pendingSelectionsGroupsPromises.set(selectionsOnTheFly, lazyPromise.promise);
    if (notifyResolve) {
      const promise = lazyPromise.promise;
      resolveListeners.forEach((subscription) => {
        subscription(promise, selection);
      });
    }
    fetchSelections(lazyPromise);
  }
  globalInterceptor.selectionCacheRefetchListeners.add((selection) => addSelectionToScheduler(selection, false));
  globalInterceptor.selectionAddListeners.add(addSelectionToScheduler);
  return scheduler;
};

export { createScheduler };
