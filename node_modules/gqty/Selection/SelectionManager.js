'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const cachedJSON = require('../Utils/cachedJSON.js');
const selection = require('./selection.js');

function separateSelectionTypes(selections) {
  let querySelections;
  let mutationSelections;
  let subscriptionSelections;
  for (const selection$1 of selections) {
    switch (selection$1.type) {
      case selection.SelectionType.Query: {
        querySelections || (querySelections = []);
        querySelections.push(selection$1);
        break;
      }
      case selection.SelectionType.Mutation: {
        mutationSelections || (mutationSelections = []);
        mutationSelections.push(selection$1);
        break;
      }
      case selection.SelectionType.Subscription: {
        subscriptionSelections || (subscriptionSelections = []);
        subscriptionSelections.push(selection$1);
        break;
      }
    }
  }
  return {
    querySelections,
    mutationSelections,
    subscriptionSelections
  };
}
const selectionsBackupVersion = "v0";
function isSelectionsBackup(selectionsBackup) {
  return Array.isArray(selectionsBackup) && Array.isArray(selectionsBackup[0]) && Array.isArray(selectionsBackup[1]) && Array.isArray(selectionsBackup[2]) && selectionsBackup[3] === selectionsBackupVersion;
}
let uniqueSelectionId = 0;
function createSelectionManager() {
  const selectionCache = new Map();
  const incIds = {};
  const aliasMap = new Map();
  let incHashId = -1;
  const stringsHash = {};
  let restoredBackup;
  function getSerializedVariablesId(variables) {
    const serializedVariables = cachedJSON.serializeVariables(variables);
    let hashId;
    if ((hashId = stringsHash[serializedVariables]) === void 0) {
      hashId = stringsHash[serializedVariables] = ++incHashId;
      if (restoredBackup)
        restoredBackup[1].push([serializedVariables, hashId]);
    }
    return hashId;
  }
  function getKeyHashId(key) {
    let hashId;
    if ((hashId = stringsHash[key]) === void 0) {
      hashId = stringsHash[key] = ++incHashId;
      if (restoredBackup)
        restoredBackup[1].push([key, hashId]);
    }
    return hashId;
  }
  function restore(backup2) {
    if (!isSelectionsBackup(backup2))
      return;
    restoredBackup = backup2;
    for (const [aliasKey, alias] of backup2[0]) {
      aliasMap.set(aliasKey, alias);
    }
    for (const [stringKey, incHashIdValue] of backup2[1]) {
      stringsHash[stringKey] = incHashIdValue;
      incHashId = incHashIdValue;
    }
    for (const [key, incId] of backup2[2]) {
      incIds[key] = incId;
    }
  }
  function backup() {
    if (restoredBackup) {
      restoredBackup[2] = [];
      for (const key in incIds)
        restoredBackup[2].push([~~key, incIds[key]]);
      return restoredBackup;
    }
    const backup2 = [[], [], [], selectionsBackupVersion];
    for (const [aliasKey, alias] of aliasMap.entries()) {
      backup2[0].push([aliasKey, alias]);
    }
    for (const serializedVariables in stringsHash) {
      backup2[1].push([serializedVariables, stringsHash[serializedVariables]]);
    }
    for (const key in incIds)
      backup2[2].push([~~key, incIds[key]]);
    return restoredBackup = backup2;
  }
  function getVariableAlias(key, variables, variableTypes) {
    var _a;
    const hashedKey = typeof key === "string" ? getKeyHashId(key) : key;
    const aliasKey = `${hashedKey}-${getSerializedVariablesId(variables)}-${getSerializedVariablesId(variableTypes)}`;
    let alias = aliasMap.get(aliasKey);
    if (alias == null) {
      (_a = incIds[hashedKey]) != null ? _a : incIds[hashedKey] = -1;
      alias = `${key}${++incIds[hashedKey]}`;
      aliasMap.set(aliasKey, alias);
      if (restoredBackup)
        restoredBackup[0].push([aliasKey, alias]);
    }
    return alias;
  }
  function getSelection({
    key,
    prevSelection,
    args,
    argTypes,
    type,
    unions
  }) {
    let alias;
    let cacheKey = key + "";
    if (args && argTypes) {
      alias = getVariableAlias(key, args, argTypes);
      cacheKey = alias;
    }
    if (prevSelection) {
      cacheKey = prevSelection.pathString + "." + cacheKey;
    }
    if (unions == null ? void 0 : unions.length) {
      cacheKey += ";" + unions.join(";");
    }
    let selection$1 = selectionCache.get(cacheKey);
    if (selection$1 == null) {
      selection$1 = new selection.Selection({
        key,
        prevSelection,
        args,
        argTypes,
        alias,
        type,
        unions,
        id: ++uniqueSelectionId
      });
      selectionCache.set(cacheKey, selection$1);
    } else if (args) {
      selection$1.args = args;
    }
    return selection$1;
  }
  return {
    getSelection,
    restore,
    backup
  };
}

exports.createSelectionManager = createSelectionManager;
exports.separateSelectionTypes = separateSelectionTypes;
