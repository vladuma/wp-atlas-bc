import { CacheInstance } from '../Cache';
import { GQtyError } from '../Error';
import type { Selection } from '../Selection/selection';
import type { InnerClientState, SubscriptionsClient } from './client';
export interface ResolveOptions<TData> {
    /**
     * Set to `true` to refetch the data requirements
     */
    refetch?: boolean;
    /**
     * Ignore the client cache
     */
    noCache?: boolean;
    /**
     * Activate special handling of non-serializable variables,
     * for example, files uploading
     *
     * @default false
     */
    nonSerializableVariables?: boolean;
    /**
     * Middleware function that is called if valid cache is found
     * for all the data requirements, it should return `true` if the
     * the resolution and fetch should continue, and `false`
     * if you wish to stop the resolution, resolving the promise
     * with the existing cache data.
     */
    onCacheData?: (data: TData) => boolean;
    /**
     * On No Cache found
     */
    onNoCacheFound?: () => void;
    /**
     * Get every selection intercepted in the specified function
     */
    onSelection?: (selection: Selection) => void;
    /**
     * On subscription event listener
     */
    onSubscription?: (event: {
        type: 'data';
        unsubscribe: () => Promise<void>;
        data: TData;
        error?: undefined;
    } | {
        type: 'with-errors';
        unsubscribe: () => Promise<void>;
        data?: TData;
        error: GQtyError;
    } | {
        type: 'start' | 'complete';
        unsubscribe: () => Promise<void>;
        data?: undefined;
        error?: undefined;
    }) => void;
    /**
     * Function called on empty resolution
     */
    onEmptyResolve?: () => void;
    /**
     * Retry strategy
     */
    retry?: RetryOptions;
}
export declare type RetryOptions = {
    /**
     * Amount of retries to be made
     * @default 3
     */
    maxRetries?: number;
    /**
     * Amount of milliseconds between each attempt, it can be a static number,
     * or a function based on the attempt number
     *
     * @default attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000)
     */
    retryDelay?: number | ((attemptIndex: number) => number);
}
/** If retries should be enabled
 * @default true
 */
 | boolean
/** Amount of retries to be made
 * @default 3
 */
 | number;
export interface FetchResolveOptions {
    retry?: RetryOptions;
    scheduler?: boolean;
    ignoreResolveCache?: boolean;
    onSubscription?: ResolveOptions<any>['onSubscription'];
}
export interface Resolved {
    <T = unknown>(dataFn: () => T, opts?: ResolveOptions<T>): Promise<T>;
}
export interface BuildAndFetchSelections {
    <TData = unknown>(selections: Selection[] | undefined, type: 'query' | 'mutation', cache?: CacheInstance, options?: FetchResolveOptions, lastTryParam?: boolean | undefined): Promise<TData | null | undefined>;
}
export interface ResolveSelections {
    (selections: Selection[] | Set<Selection>, cache?: CacheInstance, options?: FetchResolveOptions): Promise<void>;
}
export interface Resolvers {
    resolveSelections: ResolveSelections;
    buildAndFetchSelections: BuildAndFetchSelections;
    resolved: Resolved;
    inlineResolved: InlineResolved;
}
export interface InlineResolved {
    <TData = unknown>(fn: () => TData, options?: InlineResolveOptions<TData>): TData | Promise<TData>;
}
export interface InlineResolveOptions<TData> {
    refetch?: boolean;
    onEmptyResolve?: () => void;
    /**
     * Get every selection intercepted in the specified function
     */
    onSelection?: (selection: Selection) => void;
    /**
     * On valid cache data found callback
     */
    onCacheData?: (data: TData) => void;
}
export declare function createResolvers(innerState: InnerClientState, catchSelectionsTimeMS: number, subscriptions?: SubscriptionsClient): Resolvers;
