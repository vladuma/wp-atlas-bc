import { AssignSelections, SchemaUnions, SetCache } from '../Accessor';
import { AccessorCache, CacheInstance, CacheType } from '../Cache';
import { PersistenceHelpers } from '../Cache/persistence';
import { GQtyError } from '../Error';
import { EventHandler } from '../Events';
import { Prefetch } from '../Helpers/prefetch';
import { Refetch } from '../Helpers/refetch';
import { HydrateCache, PrepareRender } from '../Helpers/ssr';
import { InterceptorManager } from '../Interceptor';
import { NormalizationHandler, NormalizationOptions } from '../Normalization';
import { Scheduler } from '../Scheduler';
import type { QueryFetcher, ScalarsEnumsHash, Schema } from '../Schema/types';
import type { Selection } from '../Selection/selection';
import { SelectionManager } from '../Selection/SelectionManager';
import { BuildAndFetchSelections, InlineResolved, Resolved, Resolvers, RetryOptions } from './resolvers';
import { Track } from '../Helpers/track';
export interface InnerClientState {
    allowCache: boolean;
    foundValidCache: boolean;
    clientCache: CacheInstance;
    selectionManager: SelectionManager;
    readonly accessorCache: AccessorCache;
    readonly interceptorManager: InterceptorManager;
    readonly scheduler: Scheduler;
    readonly eventHandler: EventHandler;
    readonly schema: Readonly<Schema>;
    readonly scalarsEnumsHash: Readonly<ScalarsEnumsHash>;
    readonly queryFetcher: QueryFetcher;
    readonly schemaUnions: SchemaUnions;
    readonly normalizationHandler: NormalizationHandler | undefined;
    readonly depthLimit: number;
    defaults: CoreClientDefaults;
}
export interface SubscribeEvents {
    onData: (data: Record<string, unknown>) => void;
    onError: (payload: {
        error: GQtyError;
        data: Record<string, unknown> | null;
    }) => void;
    onStart?: () => void;
    onComplete?: () => void;
}
export declare type PossiblePromise<T> = Promise<T> | T;
export interface SubscriptionsClient {
    subscribe(opts: {
        query: string;
        variables: Record<string, unknown> | undefined;
        selections: Selection[];
        events: ((ctx: {
            selections: Selection[];
            query: string;
            variables: Record<string, unknown> | undefined;
            operationId: string;
        }) => SubscribeEvents) | SubscribeEvents;
        cacheKey?: string;
    }): PossiblePromise<{
        unsubscribe: () => Promise<void>;
        operationId: string;
    }>;
    unsubscribe(selections: Selection[] | Set<Selection>): Promise<string[]>;
    close(): Promise<void>;
    setConnectionParams(connectionParams: (() => PossiblePromise<Record<string, unknown>>) | Record<string, unknown>, restartClient?: boolean): void;
}
export interface CoreClientDefaults {
    /**
     * `resolved` defaults
     */
    resolved?: {
        /**
         * Set the default `noCache` option
         *
         * @default false
         */
        noCache?: boolean;
        /**
         * Set the default `noCache` option
         *
         * @default false
         */
        refetch?: boolean;
        /**
         * Set the default `retry` strategy
         *
         * @default false
         */
        retry?: RetryOptions;
    };
}
export interface ClientOptions<ObjectTypesNames extends string = never, SchemaObjectTypes extends {
    [P in ObjectTypesNames]: {
        __typename?: P;
    };
} = never> {
    schema: Readonly<Schema>;
    scalarsEnumsHash: ScalarsEnumsHash;
    queryFetcher: QueryFetcher;
    catchSelectionsTimeMS?: number;
    retry?: RetryOptions;
    normalization?: NormalizationOptions<ObjectTypesNames, SchemaObjectTypes> | boolean;
    subscriptionsClient?: SubscriptionsClient;
    defaults?: CoreClientDefaults;
    /**
     * Set the maximum depth limit, needed to prevent possible infinite recursion.
     *
     * After the specified depth is reached, the proxy creation is stopped returning `null`
     *
     * @default 15
     */
    depthLimit?: number;
}
export interface MutateHelpers<GeneratedSchema extends {
    query: {};
}> {
    query: GeneratedSchema['query'];
    setCache: SetCache;
    assignSelections: AssignSelections;
}
export interface Mutate<GeneratedSchema extends {
    query: {};
    mutation: {};
}> {
    <T = any>(fn: (mutation: GeneratedSchema['mutation']) => T, opts?: {
        onComplete?: (data: T, helpers: MutateHelpers<GeneratedSchema>) => void;
        onError?: (error: GQtyError, helpers: MutateHelpers<GeneratedSchema>) => void;
    }): Promise<T>;
}
export interface GQtyClient<GeneratedSchema extends {
    query: {};
    mutation: {};
    subscription: {};
}> extends PersistenceHelpers {
    query: GeneratedSchema['query'];
    mutation: GeneratedSchema['mutation'];
    subscription: GeneratedSchema['subscription'];
    resolved: Resolved;
    inlineResolved: InlineResolved;
    cache: CacheType;
    interceptorManager: InterceptorManager;
    scheduler: Scheduler;
    refetch: Refetch;
    accessorCache: AccessorCache;
    buildAndFetchSelections: BuildAndFetchSelections;
    eventHandler: EventHandler;
    setCache: SetCache;
    hydrateCache: HydrateCache;
    prepareRender: PrepareRender;
    assignSelections: AssignSelections;
    mutate: Mutate<GeneratedSchema>;
    subscriptionsClient: SubscriptionsClient | undefined;
    prefetch: Prefetch<GeneratedSchema>;
    track: Track;
}
export type { Resolved, CacheType, InterceptorManager, Scheduler, Refetch, AccessorCache, Resolvers, EventHandler, SetCache, HydrateCache, PrepareRender, AssignSelections, Prefetch, BuildAndFetchSelections, InlineResolved, };
export declare function createClient<GeneratedSchema extends {
    query: {};
    mutation: {};
    subscription: {};
} = never, ObjectTypesNames extends string = never, ObjectTypes extends {
    [P in ObjectTypesNames]: {
        __typename?: P;
    };
} = never>({ schema, scalarsEnumsHash, queryFetcher, catchSelectionsTimeMS, retry, normalization, subscriptionsClient, defaults, depthLimit, }: ClientOptions<ObjectTypesNames, ObjectTypes>): GQtyClient<GeneratedSchema>;
