import '../Selection/selection.mjs';
import { createCache } from '../Cache/dataCache.mjs';
import { GQtyError } from '../Error/index.mjs';
import { doRetry } from '../Error/retry.mjs';
import { createQueryBuilder } from '../QueryBuilder/buildQuery.mjs';
import { createSelectionManager, separateSelectionTypes } from '../Selection/SelectionManager.mjs';
import { get } from '../Utils/object.mjs';
import 'lodash/mergeWith.js';
import { LazyPromise, createDeferredPromise } from '../Utils/promise.mjs';

function filterSelectionsWithErrors(graphQLErrors, executionData, selections) {
  if (!executionData)
    return selections;
  const gqlErrorsPaths = graphQLErrors == null ? void 0 : graphQLErrors.map((err) => {
    var _a;
    return (_a = err.path) == null ? void 0 : _a.filter((pathValue) => typeof pathValue === "string").join(".");
  }).filter((possiblePath) => {
    return !!possiblePath;
  });
  const selectionsWithErrors = !(gqlErrorsPaths == null ? void 0 : gqlErrorsPaths.length) ? selections : selections.filter((selection) => {
    const selectionPathNoIndex = selection.noIndexSelections.slice(1).map((selection2) => selection2.alias || selection2.key).join(".");
    const selectionData = get(executionData, selectionPathNoIndex);
    switch (selectionData) {
      case void 0: {
        return true;
      }
      case null: {
        return gqlErrorsPaths.includes(selectionPathNoIndex);
      }
      default:
        return false;
    }
  });
  return selectionsWithErrors;
}
function createResolvers(innerState, catchSelectionsTimeMS, subscriptions) {
  const {
    interceptorManager,
    eventHandler,
    queryFetcher,
    scheduler,
    clientCache: globalCache,
    selectionManager: globalSelectionManager,
    defaults: { resolved: resolvedDefaults = {} }
  } = innerState;
  const { globalInterceptor } = interceptorManager;
  const buildQuery = createQueryBuilder();
  const inlineResolved = function inlineResolved2(fn, {
    refetch,
    onEmptyResolve,
    onSelection,
    onCacheData
  } = {}) {
    const prevFoundValidCache = innerState.foundValidCache;
    innerState.foundValidCache = true;
    const interceptor = interceptorManager.createInterceptor();
    let noSelection = true;
    function onScalarSelection() {
      noSelection = false;
    }
    interceptor.selectionAddListeners.add(onScalarSelection);
    interceptor.selectionCacheRefetchListeners.add(onScalarSelection);
    if (onSelection) {
      interceptor.selectionAddListeners.add(onSelection);
      interceptor.selectionCacheListeners.add(onSelection);
      interceptor.selectionCacheRefetchListeners.add(onSelection);
    }
    const prevAllowCache = innerState.allowCache;
    try {
      if (refetch)
        innerState.allowCache = false;
      const data = fn();
      const foundValidCache = innerState.foundValidCache;
      innerState.foundValidCache = prevFoundValidCache;
      interceptorManager.removeInterceptor(interceptor);
      innerState.allowCache = prevAllowCache;
      if (noSelection) {
        if (process.env.NODE_ENV !== "production") {
          console.warn("[gqty] Warning! No data requested.");
        }
        if (onEmptyResolve)
          onEmptyResolve();
        return data;
      }
      const promises = [];
      groups:
        for (const [
          selectionSet,
          promise
        ] of scheduler.pendingSelectionsGroupsPromises) {
          for (const selection of interceptor.fetchSelections) {
            if (selectionSet.has(selection)) {
              promises.push(promise);
              continue groups;
            }
          }
        }
      if (promises.length) {
        if (foundValidCache) {
          if (onCacheData) {
            onCacheData(data);
          }
        }
        return Promise.all(promises).then((value) => {
          for (const v of value)
            if (v.error)
              throw v.error;
          innerState.allowCache = true;
          return fn();
        });
      }
      return data;
    } finally {
      innerState.foundValidCache = prevFoundValidCache;
      interceptorManager.removeInterceptor(interceptor);
      innerState.allowCache = prevAllowCache;
    }
  };
  const {
    noCache: noCacheDefault = false,
    refetch: refetchDefault = false,
    retry: retryDefault = false
  } = resolvedDefaults;
  const resolved = async function resolved2(dataFn, {
    refetch = refetchDefault,
    noCache = noCacheDefault,
    onCacheData,
    onSelection,
    onSubscription,
    retry = retryDefault,
    nonSerializableVariables,
    onNoCacheFound,
    onEmptyResolve
  } = {}) {
    const prevFoundValidCache = innerState.foundValidCache;
    innerState.foundValidCache = true;
    let prevAllowCache = innerState.allowCache;
    if (refetch) {
      innerState.allowCache = false;
    }
    let tempCache;
    let tempSelectionManager;
    if (noCache) {
      innerState.clientCache = tempCache = createCache();
    }
    if (nonSerializableVariables) {
      innerState.selectionManager = tempSelectionManager = createSelectionManager();
    }
    let prevGlobalInterceptorListening = globalInterceptor.listening;
    globalInterceptor.listening = false;
    const interceptor = interceptorManager.createInterceptor();
    let noSelection = true;
    function onScalarSelection() {
      noSelection = false;
    }
    interceptor.selectionAddListeners.add(onScalarSelection);
    interceptor.selectionCacheRefetchListeners.add(onScalarSelection);
    if (onSelection) {
      interceptor.selectionAddListeners.add(onSelection);
      interceptor.selectionCacheListeners.add(onSelection);
      interceptor.selectionCacheRefetchListeners.add(onSelection);
    }
    try {
      const data = dataFn();
      if (noSelection) {
        if (process.env.NODE_ENV !== "production") {
          console.warn("[gqty] Warning! No data requested.");
        }
        if (onEmptyResolve)
          onEmptyResolve();
        return data;
      }
      interceptorManager.removeInterceptor(interceptor);
      if (innerState.foundValidCache) {
        if (onCacheData) {
          const shouldContinue = onCacheData(data);
          if (!shouldContinue)
            return data;
        }
      } else if (onNoCacheFound) {
        onNoCacheFound();
      }
      innerState.foundValidCache = prevFoundValidCache;
      innerState.allowCache = prevAllowCache;
      innerState.clientCache = globalCache;
      innerState.selectionManager = globalSelectionManager;
      globalInterceptor.listening = prevGlobalInterceptorListening;
      await resolveSelections(interceptor.fetchSelections, tempCache || innerState.clientCache, {
        ignoreResolveCache: refetch || noCache,
        onSubscription: onSubscription ? (event) => {
          switch (event.type) {
            case "data":
            case "with-errors":
              if (event.data) {
                const prevAllowCache2 = innerState.allowCache;
                try {
                  innerState.allowCache = true;
                  globalInterceptor.listening = false;
                  if (tempCache) {
                    innerState.clientCache = tempCache;
                  }
                  onSubscription({
                    ...event,
                    data: dataFn()
                  });
                } finally {
                  innerState.allowCache = prevAllowCache2;
                  globalInterceptor.listening = true;
                  innerState.clientCache = globalCache;
                }
              } else {
                onSubscription(event);
              }
              return;
            default:
              onSubscription(event);
          }
        } : void 0,
        retry
      });
      prevAllowCache = innerState.allowCache;
      innerState.allowCache = true;
      prevGlobalInterceptorListening = globalInterceptor.listening;
      globalInterceptor.listening = false;
      if (tempCache) {
        innerState.clientCache = tempCache;
      }
      if (tempSelectionManager) {
        innerState.selectionManager = tempSelectionManager;
      }
      return dataFn();
    } catch (err) {
      throw GQtyError.create(err, resolved2);
    } finally {
      interceptorManager.removeInterceptor(interceptor);
      innerState.allowCache = prevAllowCache;
      innerState.clientCache = globalCache;
      innerState.selectionManager = globalSelectionManager;
      innerState.foundValidCache = prevFoundValidCache;
      globalInterceptor.listening = prevGlobalInterceptorListening;
    }
  };
  const resolutionTempCache = new Map();
  const resolutionTempCacheTimeout = catchSelectionsTimeMS * 5;
  function buildQueryAndCheckTempCache(selections, type, normalizationHandler, ignoreResolveCache, isGlobalCache) {
    const { query, variables, cacheKey } = buildQuery(selections, {
      type
    }, normalizationHandler != null, isGlobalCache);
    const cachedData = ignoreResolveCache ? void 0 : resolutionTempCache.get(cacheKey);
    return {
      query,
      variables,
      cacheKey,
      cachedData
    };
  }
  const resolveQueryPromisesMap = {};
  async function buildAndFetchSelections(selections, type, cache = innerState.clientCache, options = {}, lastTryParam) {
    if (!selections)
      return;
    const isLastTry = lastTryParam === void 0 ? options.retry ? false : true : lastTryParam;
    const { query, variables, cachedData, cacheKey } = buildQueryAndCheckTempCache(selections, type, innerState.normalizationHandler, options.ignoreResolveCache, cache === globalCache);
    if (!options.scheduler)
      return resolve();
    let promise = resolveQueryPromisesMap[cacheKey];
    if (promise)
      return promise;
    promise = LazyPromise(() => {
      return resolve();
    });
    resolveQueryPromisesMap[cacheKey] = promise;
    try {
      return await promise;
    } finally {
      delete resolveQueryPromisesMap[cacheKey];
    }
    async function resolve() {
      if (!selections)
        return;
      let executionData;
      let loggingPromise;
      try {
        if (cachedData != null)
          return cachedData;
        if (eventHandler.hasFetchSubscribers) {
          loggingPromise = createDeferredPromise();
          eventHandler.sendFetchPromise(loggingPromise.promise, selections);
        }
        const executionResult = await queryFetcher(query, variables);
        const { data, errors } = executionResult;
        if (data) {
          if (!errors && cacheKey) {
            resolutionTempCache.set(cacheKey, data);
            setTimeout(() => resolutionTempCache.delete(cacheKey), resolutionTempCacheTimeout);
          }
          cache.mergeCache(data, type);
          executionData = data;
        }
        if (errors == null ? void 0 : errors.length) {
          throw GQtyError.fromGraphQLErrors(errors);
        } else if (options.scheduler) {
          innerState.scheduler.errors.removeErrors(selections);
        }
        loggingPromise == null ? void 0 : loggingPromise.resolve({
          executionResult,
          query,
          variables,
          cacheSnapshot: cache.cache,
          selections,
          type
        });
        return data;
      } catch (err) {
        const error = GQtyError.create(err, () => {
        });
        loggingPromise == null ? void 0 : loggingPromise.resolve({
          error,
          query,
          variables,
          cacheSnapshot: cache.cache,
          selections,
          type
        });
        if (options.scheduler) {
          const selectionsWithErrors = filterSelectionsWithErrors(error.graphQLErrors, executionData, selections);
          innerState.scheduler.errors.triggerError(error, selectionsWithErrors, isLastTry);
        }
        if (options.retry) {
          async function retryFn(lastTry) {
            const retryPromise = buildAndFetchSelections(selections, type, cache, Object.assign({}, options, {
              retry: false,
              ignoreResolveCache: true
            }), lastTry).then((data) => ({ data, selections: new Set(selections) }), (err2) => {
              console.error(err2);
              return {
                error: GQtyError.create(err2),
                selections: new Set(selections)
              };
            });
            if (options.scheduler) {
              const setSelections = new Set(selections);
              scheduler.pendingSelectionsGroups.add(setSelections);
              scheduler.errors.retryPromise(retryPromise, setSelections);
              retryPromise.finally(() => {
                scheduler.pendingSelectionsGroups.delete(setSelections);
              });
            }
            const { error: error2 } = await retryPromise;
            if (error2)
              throw error2;
          }
          doRetry(options.retry, {
            onLastTry() {
              return retryFn(true);
            },
            onRetry() {
              return retryFn(false);
            }
          });
        }
        throw error;
      } finally {
        interceptorManager.removeSelections(selections);
      }
    }
  }
  function subscriptionSchedulerEvents(ctx) {
    return {
      onData(data) {
        const { selections, query, operationId, variables } = ctx;
        globalCache.mergeCache(data, "subscription");
        scheduler.errors.removeErrors(selections);
        for (const selection of selections) {
          eventHandler.sendCacheChange({
            data,
            selection
          });
        }
        if (eventHandler.hasFetchSubscribers) {
          eventHandler.sendFetchPromise(Promise.resolve({
            executionResult: {
              data
            },
            cacheSnapshot: globalCache.cache,
            query,
            variables,
            selections,
            type: "subscription",
            label: `[id=${operationId}] [data]`
          }), selections);
        }
      },
      onError({ data, error }) {
        const { query, variables, selections, operationId } = ctx;
        if (data)
          globalCache.mergeCache(data, "subscription");
        scheduler.errors.triggerError(error, filterSelectionsWithErrors(error.graphQLErrors, data, selections), true);
        if (eventHandler.hasFetchSubscribers) {
          eventHandler.sendFetchPromise(Promise.resolve({
            executionResult: {
              data
            },
            error,
            cacheSnapshot: globalCache.cache,
            query,
            variables,
            selections,
            type: "subscription",
            label: `[id=${operationId}] [error]`
          }), selections);
        }
      }
    };
  }
  async function buildAndSubscribeSelections(selections, cache = innerState.clientCache, options) {
    if (!selections)
      return;
    if (!subscriptions) {
      if (typeof window !== "undefined") {
        console.error("ERROR: No subscriptions client specified!");
      }
      return;
    }
    const selectionsByRoot = new Map();
    for (const selection of selections) {
      const root = selection.selectionsList[1];
      if (!root)
        continue;
      let selectionSet = selectionsByRoot.get(root);
      if (selectionSet) {
        selectionSet.push(selection);
      } else {
        selectionSet = [selection];
        selectionsByRoot.set(root, selectionSet);
      }
    }
    const unsubscribeCallbacks = new Set();
    const unsubscribe = async () => {
      await Promise.all(Array.from(unsubscribeCallbacks).map((cb) => cb()));
    };
    for (const selections2 of selectionsByRoot.values()) {
      const { query, variables, cacheKey } = buildQueryAndCheckTempCache(selections2, "subscription", innerState.normalizationHandler, true, cache === globalCache);
      let operationId;
      const subResult = subscriptions.subscribe({
        query,
        variables,
        selections: selections2,
        cacheKey,
        events: options.scheduler ? subscriptionSchedulerEvents : {
          onData(data) {
            var _a;
            cache.mergeCache(data, "subscription");
            (_a = options.onSubscription) == null ? void 0 : _a.call(options, {
              type: "data",
              unsubscribe,
              data
            });
            if (eventHandler.hasFetchSubscribers) {
              eventHandler.sendFetchPromise(Promise.resolve({
                executionResult: {
                  data
                },
                cacheSnapshot: globalCache.cache,
                query,
                variables,
                selections: selections2,
                type: "subscription",
                label: `[id=${operationId}] [data]`
              }), selections2);
            }
          },
          onError({ data, error }) {
            var _a;
            if (data)
              cache.mergeCache(data, "subscription");
            (_a = options.onSubscription) == null ? void 0 : _a.call(options, {
              type: "with-errors",
              unsubscribe,
              data,
              error
            });
            if (eventHandler.hasFetchSubscribers) {
              eventHandler.sendFetchPromise(Promise.resolve({
                executionResult: {
                  data
                },
                error,
                cacheSnapshot: globalCache.cache,
                query,
                variables,
                selections: selections2,
                type: "subscription",
                label: `[id=${operationId}] [error]`
              }), selections2);
            }
          },
          onStart: options.onSubscription ? () => {
            var _a;
            (_a = options.onSubscription) == null ? void 0 : _a.call(options, {
              type: "start",
              unsubscribe
            });
          } : void 0,
          onComplete: options.onSubscription ? () => {
            var _a;
            (_a = options.onSubscription) == null ? void 0 : _a.call(options, {
              type: "complete",
              unsubscribe
            });
          } : void 0
        }
      });
      if (subResult instanceof Promise) {
        let loggingPromise;
        if (eventHandler.hasFetchSubscribers) {
          loggingPromise = createDeferredPromise();
          eventHandler.sendFetchPromise(loggingPromise.promise, selections2);
        }
        const { unsubscribe: unsubscribe2, operationId: operationId2 } = await subResult;
        unsubscribeCallbacks.add(unsubscribe2);
        loggingPromise == null ? void 0 : loggingPromise.resolve({
          cacheSnapshot: cache.cache,
          query,
          variables,
          selections: selections2,
          type: "subscription",
          label: `[id=${operationId2}] [created]`
        });
      } else {
        unsubscribeCallbacks.add(subResult.unsubscribe);
      }
    }
  }
  async function resolveSelections(selections, cache = innerState.clientCache, options = {}) {
    const { querySelections, mutationSelections, subscriptionSelections } = separateSelectionTypes(selections);
    try {
      await Promise.all([
        buildAndFetchSelections(querySelections, "query", cache, options),
        buildAndFetchSelections(mutationSelections, "mutation", cache, options),
        buildAndSubscribeSelections(subscriptionSelections, cache, options)
      ]);
    } catch (err) {
      throw GQtyError.create(err);
    }
  }
  return {
    resolveSelections,
    buildAndFetchSelections,
    resolved,
    inlineResolved
  };
}

export { createResolvers };
