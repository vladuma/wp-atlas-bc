import { createSchemaUnions, createAccessorCreators } from '../Accessor/index.mjs';
import { createAccessorCache } from '../Cache/accessorCache.mjs';
import { createCache } from '../Cache/dataCache.mjs';
import { createPersistenceHelpers } from '../Cache/persistence.mjs';
import { GQtyError } from '../Error/index.mjs';
import { EventHandler } from '../Events/index.mjs';
import { createPrefetch } from '../Helpers/prefetch.mjs';
import { createRefetch } from '../Helpers/refetch.mjs';
import { createSSRHelpers } from '../Helpers/ssr.mjs';
import { createInterceptorManager } from '../Interceptor/index.mjs';
import { createNormalizationHandler } from '../Normalization/index.mjs';
import { createScheduler } from '../Scheduler/index.mjs';
import { createSelectionManager } from '../Selection/SelectionManager.mjs';
import { createResolvers } from './resolvers.mjs';
import { createTracker } from '../Helpers/track.mjs';

function createClient({
  schema,
  scalarsEnumsHash,
  queryFetcher,
  catchSelectionsTimeMS = 10,
  retry,
  normalization = true,
  subscriptionsClient,
  defaults = {},
  depthLimit = 15
}) {
  const interceptorManager = createInterceptorManager();
  const { globalInterceptor } = interceptorManager;
  const accessorCache = createAccessorCache();
  const eventHandler = new EventHandler();
  const normalizationHandler = createNormalizationHandler(normalization, eventHandler, schema, scalarsEnumsHash);
  const clientCache = createCache(normalizationHandler);
  const selectionManager = createSelectionManager();
  const scheduler = createScheduler(interceptorManager, resolveSchedulerSelections, catchSelectionsTimeMS);
  const innerState = {
    allowCache: true,
    foundValidCache: true,
    clientCache,
    accessorCache,
    selectionManager,
    interceptorManager,
    schema,
    scalarsEnumsHash,
    scheduler,
    eventHandler,
    queryFetcher,
    schemaUnions: createSchemaUnions(schema),
    normalizationHandler,
    defaults,
    depthLimit
  };
  const {
    resolved,
    buildAndFetchSelections,
    resolveSelections,
    inlineResolved
  } = createResolvers(innerState, catchSelectionsTimeMS, subscriptionsClient);
  async function resolveSchedulerSelections(selections) {
    const resolvingPromise = scheduler.resolving;
    const resolvePromise = resolveSelections(selections, void 0, {
      retry: retry === void 0 ? true : retry,
      scheduler: true
    });
    globalInterceptor.removeSelections(selections);
    try {
      await resolvePromise;
    } catch (error) {
      if (resolvingPromise) {
        resolvingPromise.resolve({
          error,
          selections
        });
      }
    }
  }
  const refetch = createRefetch(innerState, resolveSelections, inlineResolved);
  const { query, mutation, subscription, setCache, assignSelections } = createAccessorCreators(innerState);
  const ssrHelpers = createSSRHelpers({
    innerState,
    query,
    refetch
  });
  async function mutate(fn, opts = {}) {
    var _a, _b;
    try {
      const data = await resolved(() => fn(mutation), {
        refetch: true
      });
      (_a = opts.onComplete) == null ? void 0 : _a.call(opts, data, {
        query,
        setCache,
        assignSelections
      });
      return data;
    } catch (err) {
      const error = GQtyError.create(err, mutate);
      (_b = opts.onError) == null ? void 0 : _b.call(opts, error, {
        query,
        setCache,
        assignSelections
      });
      throw error;
    }
  }
  const prefetch = createPrefetch(query, innerState);
  const persistenceHelpers = createPersistenceHelpers(clientCache, selectionManager);
  const tracker = createTracker(innerState, subscriptionsClient);
  return {
    query,
    mutation,
    subscription,
    resolved,
    inlineResolved,
    cache: innerState.clientCache.cache,
    interceptorManager,
    scheduler,
    refetch,
    accessorCache,
    buildAndFetchSelections,
    eventHandler,
    setCache,
    ...ssrHelpers,
    assignSelections,
    mutate,
    subscriptionsClient,
    prefetch,
    ...persistenceHelpers,
    ...tracker
  };
}

export { createClient };
