import { GQtyError } from '../Error/index.mjs';
import { debounce } from '../Utils/debounce.mjs';
import { isAnySelectionIncluded } from '../Utils/selectionsInclude.mjs';

function createTracker(innerState, subscriptionsClient) {
  const {
    interceptorManager: { createInterceptor, removeInterceptor },
    eventHandler,
    scheduler,
    clientCache
  } = innerState;
  function track(callback, { onError, refetch } = {}) {
    const trackerSelections = new Set();
    let lastError;
    function callOnError(err) {
      if (lastError && err === lastError)
        return;
      lastError = err;
      onError && onError(GQtyError.create(err, callback));
    }
    const data = { current: void 0 };
    function main(info) {
      const interceptor = createInterceptor();
      interceptor.selectionAddListeners.add((selection) => {
        trackerSelections.add(selection);
      });
      const shouldRefetch = refetch && info.type === "initial";
      try {
        if (shouldRefetch) {
          innerState.allowCache = false;
        }
        Promise.resolve(callback(info)).then((value) => {
          data.current = value;
        }).catch(callOnError);
      } catch (err) {
        callOnError(err);
      } finally {
        if (shouldRefetch) {
          innerState.allowCache = true;
        }
        removeInterceptor(interceptor);
      }
    }
    const isNotifying = { current: false };
    const debouncedCacheChange = debounce(() => {
      isNotifying.current = false;
      main({
        type: "cache_change"
      });
    }, 10);
    const unsubErrors = onError && scheduler.errors.subscribeErrors((data2) => {
      switch (data2.type) {
        case "new_error": {
          if (isAnySelectionIncluded(data2.selections, trackerSelections)) {
            callOnError(data2.newError);
          }
          return;
        }
      }
    });
    const unsubCache = eventHandler.onCacheChangeSubscribe(({ selection }) => {
      if (isNotifying.current)
        return;
      if (trackerSelections.has(selection)) {
        isNotifying.current = true;
        debouncedCacheChange();
      }
    });
    const unsubFetch = eventHandler.onFetchSubscribe((promise) => {
      promise.then(({ error, selections, executionResult }) => {
        if (isNotifying.current || !isAnySelectionIncluded(trackerSelections, selections))
          return;
        error && callOnError(error);
        if (executionResult == null ? void 0 : executionResult.data) {
          isNotifying.current = true;
          debouncedCacheChange();
        }
      });
    });
    const stopSubscriptions = subscriptionsClient && (() => {
      subscriptionsClient.unsubscribe(trackerSelections).then((operationsIds) => {
        if (eventHandler.hasFetchSubscribers && operationsIds.length) {
          const arraySelections = Array.from(trackerSelections);
          for (const id of operationsIds) {
            eventHandler.sendFetchPromise(Promise.resolve({
              query: "",
              variables: void 0,
              cacheSnapshot: clientCache.cache,
              selections: arraySelections,
              type: "subscription",
              label: `[id=${id}] [unsubscribe]`
            }), arraySelections);
          }
        }
      });
    });
    main({
      type: "initial"
    });
    return {
      stop() {
        unsubCache();
        unsubFetch();
        unsubErrors == null ? void 0 : unsubErrors();
        stopSubscriptions == null ? void 0 : stopSubscriptions();
      },
      selections: trackerSelections,
      data
    };
  }
  return { track };
}

export { createTracker };
