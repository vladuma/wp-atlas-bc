import { isEmptyObject } from '../Utils/index.mjs';
import { retrocycle, decycle } from '../Utils/cycle.mjs';
import { isPlainObject } from '../Utils/object.mjs';

function createSSRHelpers({
  query,
  refetch,
  innerState
}) {
  const hydrateCache = ({
    cacheSnapshot,
    shouldRefetch = false
  }) => {
    try {
      const recoveredCache = retrocycle(JSON.parse(cacheSnapshot));
      if (isPlainObject(recoveredCache) && isPlainObject(recoveredCache.cache)) {
        const { selections, cache } = recoveredCache;
        innerState.selectionManager.restore(selections);
        innerState.clientCache.mergeCache(cache, "query");
        if (shouldRefetch) {
          setTimeout(() => {
            refetch(query).catch(console.error);
          }, typeof shouldRefetch === "number" ? shouldRefetch : 0);
        }
      }
    } catch (err) {
      console.error(err);
    }
  };
  const prepareRender = async (render) => {
    const interceptor = innerState.interceptorManager.createInterceptor();
    let prevIgnoreCache = innerState.allowCache;
    try {
      innerState.allowCache = false;
      await render();
    } finally {
      innerState.interceptorManager.removeInterceptor(interceptor);
      innerState.allowCache = prevIgnoreCache;
    }
    await Promise.all([
      ...innerState.scheduler.pendingSelectionsGroupsPromises.values()
    ]);
    const selections = innerState.selectionManager.backup();
    const queryCache = innerState.clientCache.cache.query || {};
    const cache = {};
    for (const {
      type,
      cachePath: [, queryPath]
    } of interceptor.fetchSelections) {
      if (type === 0) {
        const value = queryCache[queryPath];
        if (value !== void 0)
          cache[queryPath] = value;
      }
    }
    return {
      cacheSnapshot: JSON.stringify({
        ...decycle({
          cache: isEmptyObject(cache) ? void 0 : cache
        }),
        selections: selections[0].length || selections[1].length ? selections : void 0
      })
    };
  };
  return {
    hydrateCache,
    prepareRender
  };
}

export { createSSRHelpers };
