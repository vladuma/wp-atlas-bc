'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const isObject = (v) => v != null && typeof v === "object";
const isPlainObject = (v) => isObject(v) && !Array.isArray(v);
const isObjectWithType = (v) => isPlainObject(v) && typeof v.__typename === "string";
function deepAssign(target, sources, onConflict) {
  for (const source of sources) {
    for (const [sourceKey, sourceValue] of Object.entries(source || {})) {
      if (sourceKey in target) {
        const targetValue = Reflect.get(target, sourceKey);
        if (sourceValue === targetValue)
          continue;
        if (isObject(sourceValue) && isObject(targetValue)) {
          const onConflictResult = onConflict == null ? void 0 : onConflict(targetValue, sourceValue);
          if (onConflictResult === void 0) {
            Reflect.set(target, sourceKey, deepAssign(targetValue, [sourceValue], onConflict));
          } else {
            Reflect.set(target, sourceKey, onConflictResult);
          }
          continue;
        }
      }
      Reflect.set(target, sourceKey, sourceValue);
    }
  }
  return target;
}
function castPath(path) {
  return Array.isArray(path) ? path : (path + "").split(".");
}
function set(object, path, value) {
  if (!isObject(object))
    return object;
  path = castPath(path);
  const length = path.length;
  const lastIndex = length - 1;
  let index = -1;
  let nested = object;
  while (nested != null && ++index < length) {
    const key = path[index] + "";
    let newValue = value;
    if (index != lastIndex) {
      const objValue = nested[key];
      newValue = void 0;
      if (newValue === void 0) {
        newValue = isObject(objValue) ? objValue : typeof path[index + 1] === "number" ? [] : {};
      }
    }
    nested[key] = newValue;
    nested = nested[key];
  }
  return object;
}
function get(object, path, defaultValue) {
  path = castPath(path);
  let index = 0;
  const length = path.length;
  while (object != null && index < length) {
    object = object[path[index++]];
  }
  const value = index && index === length ? object : defaultValue;
  return value === void 0 ? defaultValue : value;
}

exports.deepAssign = deepAssign;
exports.get = get;
exports.isObject = isObject;
exports.isObjectWithType = isObjectWithType;
exports.isPlainObject = isPlainObject;
exports.set = set;
