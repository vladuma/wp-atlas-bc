export declare type PlainObject = Record<string | number | symbol, unknown>;
export declare const isObject: (v: unknown) => v is object;
export declare const isPlainObject: (v: unknown) => v is PlainObject;
export interface ObjectWithType<Typename extends string = string> extends Record<string, unknown> {
    __typename: Typename;
}
export declare const isObjectWithType: <T extends ObjectWithType<string>>(v: unknown) => v is T;
export declare function deepAssign<T extends object>(target: object, sources: (object | undefined | null)[], onConflict?: (targetValue: object, sourceValue: object) => object | void): T;
declare type SetGetPath = readonly (string | number)[] | string | number;
export declare function set<T extends object>(object: T, path: SetGetPath, value: unknown): T;
export declare function get<Value = unknown>(object: object | null | undefined, path: SetGetPath): Value | undefined;
export declare function get<Value = unknown, DefaultValue = undefined>(object: object | null | undefined, path: SetGetPath, defaultValue: DefaultValue): Value | DefaultValue;
export declare type DeepPartial<T> = T extends Function ? T : T extends Array<infer U> ? _DeepPartialArray<U> : T extends object ? _DeepPartialObject<T> : T | undefined;
interface _DeepPartialArray<T> extends Array<DeepPartial<T>> {
}
declare type _DeepPartialObject<T> = {
    [P in keyof T]?: DeepPartial<T[P]>;
};
export declare type NonNullableObject<T> = {
    [P in keyof T]-?: NonNullable<T[P]>;
};
export {};
