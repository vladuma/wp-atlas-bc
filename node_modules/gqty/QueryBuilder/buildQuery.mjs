import { set } from '../Utils/object.mjs';
import 'lodash/mergeWith.js';
import { serializeVariables } from '../Utils/cachedJSON.mjs';

const stringSelectionTree = (v) => {
  const treeEntries = Object.entries(v);
  return treeEntries.reduce((acum, [key, value], index) => {
    if (typeof value === "object") {
      acum += key + "{";
      acum += stringSelectionTree(value);
      acum += "}";
    } else {
      acum += key + (index !== treeEntries.length - 1 ? " " : "");
    }
    return acum;
  }, "");
};
function createQueryBuilder() {
  const queryCache = {};
  return function buildQuery(selections, {
    type
  }, normalization, isGlobalCache) {
    var _a;
    let variableId = 1;
    const selectionTree = {};
    const variablesMap = new Map();
    const variableTypes = {};
    const variablesMapKeyValue = {};
    if (normalization) {
      const selectionsSet = new Set();
      for (const selection of selections) {
        if (selection.cofetchSelections) {
          for (const coFetchSelection of selection.cofetchSelections) {
            selectionsSet.add(coFetchSelection);
          }
        }
        selectionsSet.add(selection);
      }
      selections = selectionsSet;
    }
    let builtQuery;
    let idAcum = "";
    if (isGlobalCache) {
      for (const { id } of selections)
        idAcum += id;
      if (builtQuery = queryCache[idAcum])
        return builtQuery;
    }
    for (const { noIndexSelections } of selections) {
      let createSelectionBranch = function(selections2, initialValue = []) {
        return selections2.reduce((acum, { args, alias, key, argTypes, unions }, index) => {
          if (key === "$on")
            return acum;
          const argsLength = args ? Object.keys(args).length : 0;
          const selectionKey = alias ? alias + ":" + key : key;
          let leafValue;
          if (args && argTypes && argsLength) {
            leafValue = selectionKey + "(" + Object.entries(args).reduce((acum2, [key2, value], index2) => {
              const variableMapKey = argTypes[key2] + "-" + key2 + "-" + JSON.stringify(value);
              variablesMapKeyValue[variableMapKey] = value;
              const variableMapValue = variablesMap.get(variableMapKey);
              if (variableMapValue) {
                acum2 += key2 + ":$" + variableMapValue;
              } else {
                const newVariableValue = key2 + variableId++;
                const newVariableType = argTypes[key2];
                variableTypes[newVariableValue] = newVariableType;
                variablesMap.set(variableMapKey, newVariableValue);
                acum2 += key2 + ":$" + newVariableValue;
              }
              if (index2 < argsLength - 1) {
                acum2 += " ";
              }
              return acum2;
            }, "") + ")";
          } else {
            leafValue = selectionKey + "";
          }
          if (unions) {
            for (const union of unions.slice(1)) {
              const newAcum = [...acum, "...on " + union, leafValue];
              selectionBranches.push(createSelectionBranch(selections2.slice(index + 1), newAcum));
            }
            acum.push("...on " + unions[0], leafValue);
          } else {
            acum.push(leafValue);
          }
          return acum;
        }, initialValue);
      };
      const selectionBranches = [];
      selectionBranches.push(createSelectionBranch(noIndexSelections));
      for (const branch of selectionBranches) {
        if (normalization) {
          for (let i = 2; i < branch.length; ++i) {
            const typenameBranch = branch.slice(0, i);
            if ((_a = typenameBranch[typenameBranch.length - 1]) == null ? void 0 : _a.startsWith("...")) {
              continue;
            } else
              typenameBranch.push("__typename");
            set(selectionTree, typenameBranch, true);
          }
        }
        set(selectionTree, branch, true);
      }
    }
    let variables;
    if (variablesMap.size) {
      const variablesObj = {};
      variables = variablesObj;
      variablesMap.forEach((value, key) => {
        variablesObj[value] = variablesMapKeyValue[key];
      });
    }
    let query = stringSelectionTree(selectionTree);
    const variableTypesEntries = Object.entries(variableTypes);
    if (variableTypesEntries.length) {
      query = query.replace(type, type + "(" + variableTypesEntries.reduce((acum, [variableName, type2]) => {
        acum += "$" + variableName + ":" + type2;
        return acum;
      }, "") + ")");
    }
    builtQuery = {
      query,
      variables,
      cacheKey: idAcum || query + (variables ? serializeVariables(variables) : "")
    };
    if (isGlobalCache)
      queryCache[idAcum] = builtQuery;
    return builtQuery;
  };
}

export { createQueryBuilder };
