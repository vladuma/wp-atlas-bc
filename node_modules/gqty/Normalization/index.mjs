import { parseSchemaType } from '../Schema/types.mjs';
import { isObject, isObjectWithType, deepAssign } from '../Utils/object.mjs';
import mergeWith from 'lodash/mergeWith.js';

function toString(v) {
  switch (typeof v) {
    case "string":
      return v;
    case "number":
    case "bigint":
      return v + "";
    case "boolean":
      return v ? "1" : "0";
    case "object":
      return v && JSON.stringify(v);
    default:
      return null;
  }
}
function createNormalizationHandler(options, eventHandler, schema, scalarsEnumsHash) {
  if (!options)
    return;
  const { identifier, keyFields } = isObject(options) ? options : {};
  const schemaKeys = keyFields ? Object.assign({}, keyFields) : {};
  const idSchemaKey = ["id"];
  const _idSchemaKey = ["_id"];
  function addIdIfValid(idKey, typeName, schemaType, idsList) {
    const type = schemaType[idKey];
    if (!type || type.__args)
      return;
    const { pureType, isArray } = parseSchemaType(type.__type);
    if (isArray || !scalarsEnumsHash[pureType])
      return;
    schemaKeys[typeName] = idsList;
    return true;
  }
  for (const [typeName, schemaType] of Object.entries(schema)) {
    const existingKeyFields = schemaKeys[typeName];
    if (!isObject(schemaType) || Array.isArray(existingKeyFields) || existingKeyFields === null || typeName === "query" || typeName === "mutation" || typeName === "subscription" || !schemaType.__typename) {
      continue;
    }
    addIdIfValid("id", typeName, schemaType, idSchemaKey) || addIdIfValid("_id", typeName, schemaType, _idSchemaKey);
  }
  function getId(obj) {
    if (identifier) {
      const result = identifier(obj);
      if (result !== void 0)
        return result;
    }
    const keys = schemaKeys[obj.__typename];
    if (!keys)
      return;
    let id = "";
    for (const key of keys) {
      if (typeof key !== "string")
        continue;
      const value = toString(obj[key]);
      if (value !== null)
        id += value;
    }
    return id && obj.__typename + id;
  }
  const normalizedCache = {};
  const normalizedSelections = new Map();
  function getCacheFromSelection(selection, notFoundValue, cache) {
    let container;
    let containerKey;
    let currentValue = cache;
    let currentSelection;
    function getNormalized() {
      let id;
      if (isObjectWithType(currentValue) && (id = getId(currentValue))) {
        let selectionsSet = normalizedSelections.get(id);
        if (!selectionsSet) {
          selectionsSet = new Set();
          normalizedSelections.set(id, selectionsSet);
        }
        selectionsSet.add(currentSelection);
        let normalizedObject;
        if ((normalizedObject = normalizedCache[id]) && normalizedObject !== currentValue) {
          if (container && containerKey != null) {
            container[containerKey] = normalizedObject;
          }
          currentValue = normalizedObject;
        }
      }
    }
    for (const selectionValue of selection.selectionsList) {
      if (selectionValue.key === "$on")
        continue;
      currentSelection = selectionValue;
      const key = selectionValue.alias || selectionValue.key;
      if (isObject(currentValue)) {
        getNormalized();
        container = currentValue;
        containerKey = key;
        currentValue = currentValue[key];
      } else
        return notFoundValue;
    }
    getNormalized();
    return currentValue === void 0 ? notFoundValue : currentValue;
  }
  function scanNormalizedObjects(obj) {
    const pendingObjects = new Set([obj]);
    for (const container of pendingObjects) {
      for (const value of Object.values(container)) {
        if (Array.isArray(value)) {
          pendingObjects.add(value);
        } else if (isObjectWithType(value)) {
          const id = getId(value);
          let data = value;
          if (id) {
            const currentValueNormalizedCache = normalizedCache[id];
            if (currentValueNormalizedCache !== value) {
              if (currentValueNormalizedCache) {
                normalizedCache[id] = data = deepAssign({}, [currentValueNormalizedCache, value], (targetValue, sourceValue) => {
                  if (Array.isArray(targetValue) && Array.isArray(sourceValue) && targetValue.length !== sourceValue.length) {
                    return sourceValue;
                  }
                });
              } else {
                normalizedCache[id] = value;
              }
              if (eventHandler) {
                const selections = normalizedSelections.get(id);
                if (selections) {
                  for (const selection of selections) {
                    eventHandler.sendCacheChange({
                      data,
                      selection
                    });
                  }
                }
              }
            } else
              continue;
          }
          pendingObjects.add(value);
        }
      }
    }
  }
  function onObjectMergeConflict(currentValue, incomingValue) {
    if (isObjectWithType(incomingValue) && isObjectWithType(currentValue)) {
      const idNewValue = getId(incomingValue);
      if (!idNewValue)
        return;
      const idCurrentValue = getId(currentValue);
      if (idNewValue === idCurrentValue) {
        const currentObject = normalizedCache[idNewValue];
        if (currentObject !== incomingValue) {
          return normalizedCache[idNewValue] = mergeWith({}, currentObject, incomingValue, onObjectMergeConflict);
        }
        return incomingValue;
      }
    }
  }
  return {
    getId,
    getCacheFromSelection,
    scanNormalizedObjects,
    normalizedCache,
    onObjectMergeConflict,
    schemaKeys
  };
}

export { createNormalizationHandler };
