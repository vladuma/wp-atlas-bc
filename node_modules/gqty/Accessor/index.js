'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('../Error/index.js');
const types = require('../Schema/types.js');
const selection = require('../Selection/selection.js');
const index$1 = require('../Utils/index.js');
const cycle = require('../Utils/cycle.js');
const object = require('../Utils/object.js');

const ProxySymbol = Symbol("gqty-proxy");
class SchemaUnion {
  constructor(name, types, fieldsProxy) {
    this.name = name;
    this.types = types;
    this.fieldsProxy = fieldsProxy;
  }
}
function createSchemaUnions(schema) {
  const unionObjectTypesForSelections = {};
  const unions = Object.entries(schema[types.SchemaUnionsKey] || {}).reduce((acum, [name, unionTypes]) => {
    const types = unionTypes.reduce((typeAcum, objectTypeName) => {
      unionObjectTypesForSelections[objectTypeName] || (unionObjectTypesForSelections[objectTypeName] = [objectTypeName]);
      const objectType = schema[objectTypeName];
      if (objectType) {
        typeAcum[objectTypeName] = objectType;
      }
      return typeAcum;
    }, {});
    acum[name] = new SchemaUnion(name, types, unionTypes.reduce((fieldsAcum, fieldName) => {
      fieldsAcum[fieldName] = ProxySymbol;
      return fieldsAcum;
    }, {}));
    return acum;
  }, {});
  return {
    unions,
    unionObjectTypesForSelections
  };
}
function createAccessorCreators(innerState) {
  const {
    accessorCache,
    selectionManager,
    interceptorManager,
    scalarsEnumsHash,
    schema,
    eventHandler,
    schemaUnions: { unions: schemaUnions, unionObjectTypesForSelections },
    clientCache: schedulerClientCache,
    scheduler: {
      errors: { map: schedulerErrorsMap }
    },
    normalizationHandler,
    depthLimit
  } = innerState;
  const ResolveInfoSymbol = Symbol();
  const proxySymbolArray = [ProxySymbol];
  function extractDataFromProxy(value) {
    if (accessorCache.isProxy(value)) {
      const accessorSelection = accessorCache.getProxySelection(value);
      if (!accessorSelection)
        return;
      const selectionCache = innerState.clientCache.getCacheFromSelection(accessorSelection);
      if (selectionCache === void 0)
        return;
      return selectionCache;
    } else if (object.isObject(value)) {
      return cycle.retrocycle(JSON.parse(JSON.stringify(value)));
    }
    return value;
  }
  function setCache(accessorOrSelection, dataOrArgs, possibleData) {
    if (accessorOrSelection instanceof selection.Selection) {
      const data = extractDataFromProxy(dataOrArgs);
      innerState.clientCache.setCacheFromSelection(accessorOrSelection, data);
      eventHandler.sendCacheChange({
        data,
        selection: accessorOrSelection
      });
    } else if (typeof accessorOrSelection === "function") {
      if (dataOrArgs !== void 0 && typeof dataOrArgs !== "object") {
        throw new index.GQtyError("Invalid arguments of type: " + typeof dataOrArgs, {
          caller: setCache
        });
      }
      const resolveInfo = accessorOrSelection[ResolveInfoSymbol];
      if (!resolveInfo) {
        throw new index.GQtyError("Invalid gqty function", {
          caller: setCache
        });
      }
      const selection = innerState.selectionManager.getSelection({
        ...resolveInfo,
        args: dataOrArgs
      });
      const data = extractDataFromProxy(possibleData);
      innerState.clientCache.setCacheFromSelection(selection, data);
      eventHandler.sendCacheChange({
        data,
        selection
      });
    } else if (accessorCache.isProxy(accessorOrSelection)) {
      const selection = accessorCache.getProxySelection(accessorOrSelection);
      if (!selection) {
        throw new index.GQtyError("Invalid proxy selection", {
          caller: setCache
        });
      }
      const data = extractDataFromProxy(dataOrArgs);
      innerState.clientCache.setCacheFromSelection(selection, data);
      eventHandler.sendCacheChange({
        data,
        selection
      });
    } else {
      throw new index.GQtyError("Invalid gqty proxy", {
        caller: setCache
      });
    }
  }
  function createArrayAccessor(schemaValue, prevSelection, unions, parentTypename) {
    const arrayCacheValue = innerState.clientCache.getCacheFromSelection(prevSelection);
    if (innerState.allowCache && arrayCacheValue === null)
      return null;
    const proxyValue = arrayCacheValue === void 0 || !Array.isArray(arrayCacheValue) || !innerState.allowCache && Array.isArray(arrayCacheValue) && arrayCacheValue.length === 0 ? proxySymbolArray : arrayCacheValue;
    const accessor = accessorCache.getArrayAccessor(prevSelection, proxyValue, () => {
      return new Proxy(proxyValue, {
        set(_target, key, value) {
          let index;
          try {
            index = parseInt(key);
          } catch (err) {
          }
          if (index$1.isInteger(index)) {
            const selection = innerState.selectionManager.getSelection({
              key: index,
              prevSelection
            });
            const data = extractDataFromProxy(value);
            innerState.clientCache.setCacheFromSelection(selection, data);
            eventHandler.sendCacheChange({
              selection,
              data
            });
            return true;
          }
          if (key === "length") {
            if (!Array.isArray(arrayCacheValue)) {
              console.warn("Invalid array assignation to unresolved proxy array");
              return true;
            }
            Reflect.set(arrayCacheValue, key, value);
            eventHandler.sendCacheChange({
              selection: prevSelection,
              data: innerState.clientCache.getCacheFromSelection(prevSelection)
            });
            return true;
          }
          throw TypeError("Invalid array assignation: " + key);
        },
        get(target, key, receiver) {
          if (key === "length") {
            if (proxyValue === proxySymbolArray) {
              const lengthSelection = innerState.selectionManager.getSelection({
                key: 0,
                prevSelection
              });
              const childAccessor = createAccessor(schemaValue, lengthSelection, unions, parentTypename);
              accessorCache.addAccessorChild(accessor, childAccessor);
              if (childAccessor)
                Reflect.get(childAccessor, "__typename");
            }
            return target.length;
          } else if (key === "toJSON") {
            return () => cycle.decycle(innerState.clientCache.getCacheFromSelection(prevSelection, []));
          }
          let index;
          try {
            index = parseInt(key);
          } catch (err) {
          }
          if (index$1.isInteger(index)) {
            const selection = innerState.selectionManager.getSelection({
              key: index,
              prevSelection
            });
            interceptorManager.addSelectionCache(selection);
            if (innerState.allowCache && arrayCacheValue !== void 0 && (arrayCacheValue == null ? void 0 : arrayCacheValue[index]) == null) {
              return arrayCacheValue == null ? void 0 : arrayCacheValue[index];
            }
            const childAccessor = createAccessor(schemaValue, selection, unions, parentTypename);
            accessorCache.addAccessorChild(accessor, childAccessor);
            return childAccessor;
          }
          return Reflect.get(target, key, receiver);
        }
      });
    });
    return accessor;
  }
  const notFoundObjectKey = {};
  const nullObjectKey = {};
  const unionsCacheValueMap = new WeakMap();
  function getCacheValueReference(cacheValue, unions) {
    if (unions === void 0)
      return cacheValue;
    const mapKey = cacheValue == null ? nullObjectKey : typeof cacheValue === "object" ? cacheValue : notFoundObjectKey;
    let cacheValueMap = unionsCacheValueMap.get(unions);
    if (!cacheValueMap) {
      cacheValueMap = new WeakMap();
      cacheValueMap.set(unions, mapKey);
    }
    let cacheReference = cacheValueMap.get(mapKey);
    if (!cacheReference) {
      cacheReference = {};
      cacheValueMap.set(mapKey, cacheReference);
    }
    return cacheReference;
  }
  function getCacheTypename(selection) {
    const cacheValue = innerState.clientCache.getCacheFromSelection(selection);
    if (object.isObjectWithType(cacheValue))
      return cacheValue.__typename;
    interceptorManager.addSelection(innerState.selectionManager.getSelection({
      key: "__typename",
      prevSelection: selection
    }));
  }
  const emptyScalarArray = Object.freeze([]);
  const querySelection = selectionManager.getSelection({
    key: "query",
    type: selection.SelectionType.Query
  });
  const mutationSelection = selectionManager.getSelection({
    key: "mutation",
    type: selection.SelectionType.Mutation
  });
  const subscriptionSelection = selectionManager.getSelection({
    key: "subscription",
    type: selection.SelectionType.Subscription
  });
  function createAccessor(schemaValue, prevSelection, unions, parentTypename) {
    let cacheValue = innerState.clientCache.getCacheFromSelection(prevSelection);
    if (innerState.allowCache && cacheValue === null)
      return null;
    const accessor = accessorCache.getAccessor(prevSelection, getCacheValueReference(cacheValue, unions), () => {
      const isUnionsInterfaceSelection = Boolean(unions && parentTypename);
      if (normalizationHandler && (parentTypename || unions)) {
        if (unions) {
          const schemaKeys = normalizationHandler.schemaKeys;
          for (const objectTypeName of unions) {
            const objectNormalizationKeys = schemaKeys[objectTypeName];
            if (objectNormalizationKeys == null ? void 0 : objectNormalizationKeys.length) {
              const coFetchSelections = objectNormalizationKeys.map((key) => innerState.selectionManager.getSelection({
                key,
                prevSelection,
                unions: unionObjectTypesForSelections[objectTypeName] || [
                  objectTypeName
                ]
              }));
              prevSelection.addCofetchSelections(coFetchSelections);
            }
          }
        } else if (parentTypename) {
          const normalizationKeys = normalizationHandler.schemaKeys[parentTypename];
          if (normalizationKeys == null ? void 0 : normalizationKeys.length) {
            const selections = normalizationKeys.map((key) => innerState.selectionManager.getSelection({
              key,
              prevSelection
            }));
            prevSelection.addCofetchSelections(selections);
          }
        }
      }
      const autoFetchUnionTypename = isUnionsInterfaceSelection ? () => {
        if (isUnionsInterfaceSelection) {
          interceptorManager.addSelection(innerState.selectionManager.getSelection({
            key: "__typename",
            prevSelection
          }));
        }
      } : void 0;
      const proxyValue = schemaValue instanceof SchemaUnion ? schemaValue.fieldsProxy : Object.keys(schemaValue).reduce((acum, key) => {
        acum[key] = ProxySymbol;
        return acum;
      }, {});
      return new Proxy(proxyValue, {
        set(_target, key, value) {
          if (!proxyValue.hasOwnProperty(key))
            throw TypeError("Invalid proxy assignation");
          const targetSelection = innerState.selectionManager.getSelection({
            key,
            prevSelection,
            unions
          });
          const data = extractDataFromProxy(value);
          innerState.clientCache.setCacheFromSelection(targetSelection, data);
          eventHandler.sendCacheChange({
            data,
            selection: targetSelection
          });
          return true;
        },
        get(_target, key, _receiver) {
          if (key === "toJSON")
            return () => cycle.decycle(innerState.clientCache.getCacheFromSelection(prevSelection, {}));
          if (schemaValue instanceof SchemaUnion) {
            if (!(key in schemaValue.types))
              return;
            if (innerState.allowCache) {
              const typename = getCacheTypename(prevSelection);
              if (typename && typename !== key)
                return;
            }
            return createAccessor(schemaValue.types[key], prevSelection, [key], key);
          }
          if (!proxyValue.hasOwnProperty(key))
            return;
          const { __type, __args } = schemaValue[key];
          let { pureType, isArray } = types.parseSchemaType(__type);
          const resolve = (args) => {
            const selection = innerState.selectionManager.getSelection({
              key,
              prevSelection,
              args: args != null ? args.argValues : void 0,
              argTypes: args != null ? args.argTypes : void 0,
              unions
            });
            if (selection.selectionsList.length > depthLimit)
              return null;
            interceptorManager.addSelectionCache(selection);
            if (scalarsEnumsHash[pureType]) {
              const cacheValue2 = innerState.clientCache.getCacheFromSelection(selection);
              accessorCache.addSelectionToAccessorHistory(accessor, selection);
              if (cacheValue2 === void 0) {
                innerState.foundValidCache = false;
                let unionTypename;
                const isUnionWithDifferentTypeResult = isUnionsInterfaceSelection ? !!(unionTypename = getCacheTypename(prevSelection)) && unionTypename !== parentTypename : false;
                if (selection.type === 2 || !isUnionWithDifferentTypeResult && (schedulerClientCache !== innerState.clientCache || !schedulerErrorsMap.has(selection))) {
                  interceptorManager.addSelection(selection);
                  autoFetchUnionTypename == null ? void 0 : autoFetchUnionTypename();
                }
                return isArray ? emptyScalarArray : void 0;
              } else if (!innerState.allowCache || selection.type === 2) {
                interceptorManager.addSelection(selection);
                autoFetchUnionTypename == null ? void 0 : autoFetchUnionTypename();
              } else {
                interceptorManager.addSelectionCacheRefetch(selection);
              }
              return cacheValue2;
            }
            let typeValue = schema[pureType];
            if (!typeValue && pureType.startsWith("$")) {
              typeValue = schemaUnions[pureType = pureType.slice(1)];
            }
            if (typeValue) {
              const childAccessor = (isArray ? createArrayAccessor : createAccessor)(typeValue, selection, void 0, pureType);
              accessorCache.addAccessorChild(accessor, childAccessor);
              return childAccessor;
            }
            throw new index.GQtyError(`GraphQL Type not found: ${pureType}, available fields: "${Object.keys(schemaValue).join(" | ")}"`);
          };
          if (__args) {
            const resolveInfo = {
              key,
              prevSelection,
              argTypes: __args
            };
            return Object.assign(function ProxyFn(argValues = emptyVariablesObject) {
              return resolve({
                argValues,
                argTypes: __args
              });
            }, {
              [ResolveInfoSymbol]: resolveInfo
            });
          }
          return resolve();
        }
      });
    });
    return accessor;
  }
  const query = createAccessor(schema.query, querySelection);
  const mutation = createAccessor(schema.mutation, mutationSelection);
  const subscription = createAccessor(schema.subscription, subscriptionSelection);
  function assignSelections(source, target) {
    if (source == null || target == null)
      return;
    let sourceSelection;
    let targetSelection;
    if (!accessorCache.isProxy(source) || !(sourceSelection = accessorCache.getProxySelection(source)))
      throw new index.GQtyError("Invalid source proxy", {
        caller: assignSelections
      });
    if (!accessorCache.isProxy(target) || !(targetSelection = accessorCache.getProxySelection(target)))
      throw new index.GQtyError("Invalid target proxy", {
        caller: assignSelections
      });
    const sourceSelections = accessorCache.getSelectionSetHistory(source);
    if (!sourceSelections) {
      if (process.env.NODE_ENV !== "production") {
        console.warn("Source proxy doesn't have any selections made");
      }
      return;
    }
    for (const selection of sourceSelections) {
      let mappedSelection = targetSelection;
      const filteredSelections = selection.selectionsList.filter((value) => !sourceSelection.selectionsList.includes(value));
      for (const { key, args, argTypes } of filteredSelections) {
        mappedSelection = innerState.selectionManager.getSelection({
          key,
          args,
          argTypes,
          prevSelection: mappedSelection
        });
      }
      accessorCache.addSelectionToAccessorHistory(target, mappedSelection);
      interceptorManager.addSelection(mappedSelection);
    }
  }
  return {
    createAccessor,
    createArrayAccessor,
    assignSelections,
    setCache,
    query,
    mutation,
    subscription
  };
}
const emptyVariablesObject = {};

exports.SchemaUnion = SchemaUnion;
exports.createAccessorCreators = createAccessorCreators;
exports.createSchemaUnions = createSchemaUnions;
